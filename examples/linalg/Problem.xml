<?xml version="1.0" encoding="UTF-8" ?><prob xmlns="urn:TI.Problem" ver="1.0"><sym><e t="6" f="196608"><n>check_type_arg</n><p>arg,expected,number</p><v>Func&#13;:Local type,test,va&#13;:test:=true&#13;:©Disp getType(arg),expected&#13;:type:=lib_msg(expected,false)&#13;:If expected=&quot;SQM&quot; Then&#13;:   If getType(arg)=&quot;MAT&quot; Then&#13;:       test:=colDim(arg)=rowDim(arg)&#13;:   Else&#13;:       test:=false&#13;:   EndIf&#13;:ElseIf expected=&quot;VEC&quot; Then&#13;:  If getType(arg)=&quot;MAT&quot; Then&#13;:     test:=colDim(arg)=1&#13;:  Else&#13;:     test:=false&#13;:  EndIf&#13;:ElseIf expected=&quot;SCAL&quot; Then&#13;:   va:=abs(approx(arg))&#13;:   test:=getType(va)=&quot;NUM&quot;&#13;:ElseIf expected=&quot;VAR&quot; Then&#13;:   test:=getType(arg)=&quot;EXPR&quot; or getType(arg)=&quot;NONE&quot;&#13;:ElseIf expected=&quot;POSINT&quot; Then&#13;:  If getType(arg)=&quot;NUM&quot; Then&#13;:     test:=floor(arg)=arg and arg≥0&#13;:  Else&#13;:     test:=false&#13;:  EndIf&#13;:Else&#13;:  test:=getType(arg)=expected&#13;:EndIf&#13;:If not test Then&#13;:If number&gt;0 Then&#13;:      lib_msg(&quot;err&quot;,false)&amp;lib_msg(&quot;arg#&quot;,false)&amp;string(number)&amp;lib_msg(&quot;sh_be&quot;,false)&amp;type&#13;:Else&#13;:      lib_msg(&quot;err&quot;,false)&amp;lib_msg(&quot;arg&quot;,false)&amp;lib_msg(&quot;sh_be&quot;,false)&amp;type&#13;:    EndIf&#13;:Else&#13;:&quot;ok&quot;&#13;:EndIf&#13;:EndFunc</v></e><e t="7" f="65536"><n>clearmat</n><p></p><v>Prgm&#13;:©clearmat(): delete temporary matrices&#13;:dispstring(&quot;DelVar θmatg,θmatinv,θsol&quot;)&#13;:DelVar θmatg,θmatinv,θsol&#13;:EndPrgm</v></e><e t="6" f="65536"><n>cofactor</n><p>mat,i0,j0</p><v>Func&#13;:©cofactor(matrix,i,j)&#13;:Local i,j,m,s1&#13;:s1:=check_type_arg(mat,&quot;SQM&quot;,1)&#13;:If s1≠&quot;ok&quot; Then&#13;:Return s1&#13;:EndIf&#13;:s1:=check_type_arg(i0,&quot;POSINT&quot;,2)&#13;:If s1≠&quot;ok&quot; Then&#13;:Return s1&#13;:EndIf&#13;:s1:=check_type_arg(j0,&quot;POSINT&quot;,3)&#13;:If s1≠&quot;ok&quot; Then&#13;:Return s1&#13;:EndIf&#13;:If i0&gt;rowDim(mat) Then&#13;:Return &quot;rowdim&lt;&quot;&amp;string(i0)&#13;:EndIf&#13;:If j0&gt;colDim(mat) Then&#13;:Return &quot;coldim&lt;&quot;&amp;string(j0)&#13;:EndIf&#13;:m:=mat&#13;: For i,1,rowDim(m):m[i,j0]:=0:EndFor: For j,1,rowDim(m):m[i0,j]:=0:EndFor: m[i0,j0]:=1: det(m)&#13;:EndFunc</v></e><e t="6" f="196608"><n>dispstring</n><p>st</p><v>Func&#13;:  expr(&quot;disp &quot;&quot;&quot;&amp;st&amp;&quot;&quot;&quot;&quot;)&#13;:  st&#13;:EndFunc</v></e><e t="7" f="196608"><n>gauss1</n><p>l,c,nbl</p><v>Prgm&#13;:Local i&#13;:If not condpiv(l,c) Then&#13;:   For i,l+1,nbl&#13;:     If condpiv(i,c) Then&#13;:       gauss2(i,0,l)&#13;:       Exit&#13;:     EndIf&#13;:   EndFor&#13;:EndIf&#13;:EndPrgm</v></e><e t="7" f="196608"><n>gauss2</n><p>i1,k,i2</p><v>Prgm&#13;: Local s1,s2,lab&#13;:lab:=lib_msg(&quot;row&quot;,false)&#13;:lab&amp;string(i1)→s1&#13;:lab&amp;string(i2)→s2&#13;: If i2=0 Then&#13;:       If k=−1 Then&#13;:       dispstring(s1&amp;&quot;= -&quot;&amp;s1)&#13;:       Else&#13;:       dispstring(s1&amp;&quot;=&quot;&amp;string(k)&amp;&quot;·&quot;&amp;s1)&#13;:       EndIf&#13;:       mRow(k,θmatg,i1)→θmatg&#13;:ElseIf k=0 Then&#13;:       dispstring(s1&amp;&quot; &lt;-&gt;&quot;&amp;s2)&#13;:       rowSwap(θmatg,i1,i2)→θmatg&#13;:Else&#13;:       If k=1 Then&#13;:                 dispstring(s1&amp;&quot;=&quot;&amp;s1&amp;&quot;+&quot;&amp;s2)&#13;:       ElseIf k=−1 Then&#13;:                 dispstring(s1&amp;&quot;=&quot;&amp;s1&amp;&quot;-&quot;&amp;s2)&#13;:       ElseIf k&gt;0 Then&#13;:          dispstring(s1&amp;&quot;=&quot;&amp;s1&amp;&quot;+&quot;&amp;string(k)&amp;&quot;·&quot;&amp;s2)&#13;:       Else&#13;:          dispstring(s1&amp;&quot;=&quot;&amp;s1&amp;&quot;-&quot;&amp;string(abs(k))&amp;&quot;·&quot;&amp;s2)&#13;:       EndIf&#13;:       mRowAdd(k,θmatg,i2,i1)→θmatg&#13;:EndIf&#13;:Disp θmatg&#13;:EndPrgm</v></e><e t="7" f="65536"><n>gausstep</n><p>mat</p><v>Prgm&#13;:©gausstep(Mat): step-by-step row reduc.&#13;:Local i,l,c,k,nbl,nbc,s&#13;:s:=check_type_arg(mat,&quot;MAT&quot;,0)&#13;:If s≠&quot;ok&quot; Then&#13;:    dispstring(s)&#13;:Else&#13;:Disp mat&#13;:dim(mat)→l&#13;:l[1]→nbl&#13;:l[2]→nbc&#13;:mat→θmatg&#13;:1→l&#13;:1→c&#13;:While l≤nbl and c≤nbc&#13;:    Define condpiv(l,c)=θmatg[l,c]=1&#13;:    gauss1(l,c,nbl)&#13;:    Define condpiv(l,c)=θmatg[l,c]^2=1&#13;:    gauss1(l,c,nbl)&#13;:    Define condpiv(l,c)=θmatg[l,c]≠0&#13;:    gauss1(l,c,nbl)&#13;:    If θmatg[l,c]≠0 Then&#13;:     For i,l+1,nbl&#13;:       If θmatg[i,c]≠0 Then&#13;:−θmatg[i,c]/(θmatg[l,c])→k&#13;:          gauss2(i,k,l)&#13;:       EndIf&#13;:     EndFor&#13;:    l+1→l&#13;: EndIf&#13;: c+1→c&#13;: EndWhile&#13;: dispstring(lib_msg(&quot;rank&quot;,false)&amp;&quot; = &quot;&amp;string(l-1))&#13;: DelVar condpiv&#13;: EndIf&#13;:EndPrgm</v></e><e t="7" f="65536"><n>help</n><p></p><v>Prgm&#13;:  ©help()&#13;:  If getLangInfo()=&quot;fr&quot; Then&#13;:  help_fr()&#13;:  ElseIf getLangInfo()=&quot;de&quot; Then&#13;:  help_ge()&#13;:  Else&#13;:  help_en()&#13;:  EndIf&#13;:EndPrgm</v></e><e t="7" f="196608"><n>help_en</n><p></p><v>Prgm&#13;:  ©help(): syntax info for linalg&#13;:  Disp &quot;clearmat() - delete temporary matrices&quot;&#13;:  Disp &quot;cofactor(Matrix,i,j) - cofactor Cij&quot;&#13;:  Disp &quot;gausstep(Matrix) - step by step row matrix reduction.&quot;&#13;:  Disp &quot;inversestep(Matrix) - step by step matrix inverse computation.&quot;&#13;:  Disp &quot;kernelbasis(Matrix) - basis of kernel (null space) of a matrix&quot;&#13;:  Disp &quot;rank(Matrix) - rank of a matrix&quot;&#13;:  Disp &quot;simultstep(Matrix,Vector) - step by step simult.&quot;&#13;:  Disp &quot;  Example: to solve system of linear equations x+2y=5, 3x+4y=6, enter:&quot;&#13;:  Disp &quot;  linalg\simultstep(&quot;,[[1,2][3,4]],&quot;,&quot;,[[5][6]],&quot;)&quot;&#13;:EndPrgm</v></e><e t="7" f="196608"><n>help_fr</n><p></p><v>Prgm&#13;:  ©help_fr(): syntax info for linalg&#13;:  Disp &quot;clearmat() - effacement des matrices temporaires&quot;&#13;:  Disp &quot;cofactor(Matrix,i,j) - cofacteur Cij&quot;&#13;:  Disp &quot;gausstep(Matrix) - réduction de Gauss pas à pas.&quot;&#13;:  Disp &quot;inversestep(Matrix) - inversion d&apos;une matrice pas à pas.&quot;&#13;:  Disp &quot;kernelbasis(Matrix) - base du noyau de l&apos;application linéaire associée&quot;&#13;:  Disp &quot;rank(Matrix) - rang d&apos;une matrice&quot;&#13;:  Disp &quot;simultstep(Matrix,Vector) - version pas à pas de simult()&quot;&#13;:  Disp &quot;   Exemple: pour résoudre le système x+2y=5, 3x+4y=6, entrer:&quot;&#13;:  Disp &quot;   linalg\simultstep(&quot;,[[1,2][3,4]],&quot;,&quot;,[[5][6]],&quot;)&quot;&#13;:EndPrgm</v></e><e t="7" f="196608"><n>help_ge</n><p></p><v>Prgm&#13;:  ©help(): syntax info for linalg&#13;:  ©Adaptation to German done by Wolfgang Pröpper&#13;:  Disp &quot;clearmat() - lösche temporäre Matrizen&quot;&#13;:  Disp &quot;cofactor(Matrix,i,j) - cofactor Cij&quot;&#13;:  Disp &quot;gausstep(Matrix) - schrittweise Gauss-Reduktion einer Matrix&quot;&#13;:  Disp &quot;inversestep(Matrix) - schrittweise Berechnung der Inversen einer Matrix.&quot;&#13;:  Disp &quot;kernelbasis(Matrix) - Basis des Kerns (Nullraum) einer Matrix.&quot;&#13;:  Disp &quot;rank(Matrix) - Rang einer Matrix&quot;&#13;:  Disp &quot;simultstep(Matrix,Vector) - schrittweise Ausführung von simult()&quot;&#13;:  Disp &quot;   Beispiel: Zum Lösen des linearen Systems x+2y=5, 3x+4y=6, geben Sie ein:&quot;&#13;:  Disp &quot;   linalg\simultstep(&quot;,[[1,2][3,4]],&quot;,&quot;,[[5][6]],&quot;)&quot;&#13;:EndPrgm</v></e><e t="7" f="65536"><n>inversestep</n><p>mat</p><v>Prgm&#13;: ©inversestep(mat): step-by-step inverse&#13;: Local i,k,c,m,nbl,nbc,matinv,s&#13;: s:=check_type_arg(mat,&quot;SQM&quot;,0)&#13;: If s≠&quot;ok&quot; Then&#13;:   dispstring(s)&#13;: Else&#13;: rowDim(mat)→nbl&#13;: colDim(mat)→nbc&#13;: If det(mat)=0 Then&#13;:   gausstep(mat)&#13;:   lib_msg(&quot;singular&quot;,true)&#13;: Else&#13;:   augment(mat,0*mat+1)→m&#13;:   Disp m&#13;:   gausstep(m)&#13;:   lib_msg(&quot;is_inv&quot;,true)&#13;:   For c,nbl,1,−1&#13;:     For i,c-1,1,−1&#13;:       If θmatg[i,c]≠0 Then&#13;:−θmatg[i,c]/(θmatg[c,c])→k&#13;:           gauss2(i,k,c)&#13;:       EndIf&#13;:     EndFor&#13;:   EndFor&#13;:   For i,1,nbl&#13;:    If θmatg[i,i]≠1 Then&#13;:        gauss2(i,1/(θmatg[i,i]),0)&#13;:    EndIf&#13;:   EndFor&#13;:   subMat(θmatg,1,nbc+1,nbl,2*nbc)→θmatinv&#13;:   Disp &quot;θmatinv=&quot;,θmatinv&#13;: EndIf&#13;: EndIf&#13;:EndPrgm</v></e><e t="6" f="196608"><n>is_sq_matrix</n><p>m</p><v>Func&#13;:©LibPriv function&#13;:rowDim(m)=colDim(m)&#13;:EndFunc</v></e><e t="6" f="65536"><n>kernelbasis</n><p>m</p><v>Func&#13;:©kernelbasis(Mat)&#13;:Local a,s&#13;:s:=check_type_arg(m,&quot;SQM&quot;,0)&#13;:If s≠&quot;ok&quot; Then&#13;:  s&#13;:ElseIf det(m)≠0 Then&#13;:[[0]]&#13;:Else&#13;:  a:=rref(augment(m,1+0*m))&#13;:(subMat(a,rank(m)+1,rowDim(m)+1))&#13;:EndIf&#13;:EndFunc</v></e><e t="6" f="196608"><n>lib_msg</n><p>msgcode,flagdisp</p><v>Func&#13;:©Libpriv function (msgcode)&#13;:If getLangInfo()=&quot;fr&quot; Then&#13;:  Return lib_msg_fr(msgcode,flagdisp)&#13;:ElseIf getLangInfo()=&quot;de&quot; Then&#13;:  Return lib_msg_ge(msgcode,flagdisp)&#13;:Else&#13;:  Return lib_msg_en(msgcode,flagdisp)&#13;:EndIf&#13;:EndFunc</v></e><e t="6" f="196608"><n>lib_msg_en</n><p>msgcode,flagdisp</p><v>Func&#13;:©Libpriv function (msgcode)&#13;:Local i,nb,flag,msg&#13;:i:=0&#13;:flag:=false&#13;:msg:=msgcode&#13;:nb:=rowDim(lib_strings_en)&#13;:While i&lt;nb and flag=false&#13;:i:=i+1&#13;:If lib_strings_en[i,1]=msgcode Then&#13;:  msg:=lib_strings_en[i,2]&#13;:  flag:=true&#13;:EndIf&#13;:EndWhile&#13;:If flagdisp:expr(&quot;Disp &quot;&quot;&quot;&amp;msg&amp;&quot;&quot;&quot;&quot;)&#13;:msg&#13;:EndFunc</v></e><e t="6" f="196608"><n>lib_msg_fr</n><p>msgcode,flagdisp</p><v>Func&#13;:©Libpriv function (msgcode)&#13;:Local i,nb,flag,msg&#13;:i:=0&#13;:flag:=false&#13;:msg:=msgcode&#13;:nb:=rowDim(lib_strings_fr)&#13;:While i&lt;nb and flag=false&#13;:i:=i+1&#13;:If lib_strings_fr[i,1]=msgcode Then&#13;:  msg:=lib_strings_fr[i,2]&#13;:  flag:=true&#13;:EndIf&#13;:EndWhile&#13;:If flagdisp:expr(&quot;Disp &quot;&quot;&quot;&amp;msg&amp;&quot;&quot;&quot;&quot;)&#13;:msg&#13;:EndFunc</v></e><e t="6" f="196608"><n>lib_msg_ge</n><p>msgcode,flagdisp</p><v>Func&#13;:©Libpriv function (msgcode)&#13;:Local i,nb,flag,msg&#13;:i:=0&#13;:flag:=false&#13;:msg:=msgcode&#13;:nb:=rowDim(lib_strings_ge)&#13;:While i&lt;nb and flag=false&#13;:i:=i+1&#13;:If lib_strings_ge[i,1]=msgcode Then&#13;:  msg:=lib_strings_ge[i,2]&#13;:  flag:=true&#13;:EndIf&#13;:EndWhile&#13;:If flagdisp:expr(&quot;Disp &quot;&quot;&quot;&amp;msg&amp;&quot;&quot;&quot;&quot;)&#13;:msg&#13;:EndFunc</v></e><e t="5" f="196608"><n>lib_name</n><v>&quot;linalg&quot;</v></e><e t="2" f="196608"><n>lib_strings</n><v>[[&quot;row&quot;,&quot;row&quot;][&quot;rank&quot;,&quot;Rank&quot;][&quot;θdθn&quot;,&quot;θd diagonal and θn nilpotent&quot;][&quot;θw&quot;,&quot;Wronskian matrix (θw)&quot;][&quot;θsh&quot;,&quot;Solutions of X&apos;=A X (θsh)&quot;][&quot;θse&quot;,&quot;Solutions of X&apos;=A X + B  (θse)&quot;][&quot;dbl_chk&quot;,&quot;Let&apos;s double-check&quot;][&quot;eigenvals&quot;,&quot;Eigenvalue(s) :&quot;][&quot;eigensp_basis&quot;,&quot;Eigenspace basis :&quot;][&quot;rref_mλ&quot;,&quot;Row reduction form of M-λI: &quot;][&quot;is_diag&quot;,&quot;This matrix is diagonalizable&quot;][&quot;is_not_diag&quot;,&quot;This matrix is not diagonalizable&quot;][&quot;is_inv&quot;,&quot;This matrix is invertible&quot;][&quot;singular&quot;,&quot;This is a singular matrix&quot;][&quot;minpoly&quot;,&quot;Minimal polynomial&quot;][&quot;nilpotent&quot;,&quot;This is a nilpotent matrix&quot;][&quot;zeropwr&quot;,&quot;Powers are equal to 0 for&quot;][&quot;not_unique&quot;,&quot;This system doesn&apos;t have a unique solution&quot;][&quot;too_cplx&quot;,&quot;Error: formal parameter or too complex coefficient&quot;][&quot;not_square&quot;,&quot;Error: this is not a square matrix&quot;][&quot;symb_fail&quot;,&quot;Error: unable to compute exact eigenvalues&quot;][&quot;MAT&quot;,&quot;a matrix&quot;][&quot;POSINT&quot;,&quot;a positive integer&quot;][&quot;VAR&quot;,&quot;a symbolic var&quot;][&quot;NONE&quot;,&quot;a symbolic var&quot;][&quot;EXPR&quot;,&quot;an expression&quot;][&quot;STR&quot;,&quot;a string&quot;][&quot;SQM&quot;,&quot;a square matrix&quot;][&quot;VEC&quot;,&quot;a column vector&quot;][&quot;NUM&quot;,&quot;a rational number&quot;][&quot;SCAL&quot;,&quot;a number&quot;][&quot;different_rows_dims&quot;,&quot;Error: row dimensions of args do not match.&quot;][&quot;not_eg_val&quot;,&quot;This is not an eigenvalue.&quot;][&quot;use&quot;,&quot;Please use&quot;][&quot;before_use&quot;,&quot;before using this program&quot;][&quot;err_constructmat&quot;,&quot;First argument must be given as a string, for example, constructmat(&quot;&quot;i+j&quot;&quot;,3,3)&quot;][&quot;err&quot;,&quot;Error: &quot;][&quot;arg#&quot;,&quot;argument #&quot;][&quot;arg&quot;,&quot;argument&quot;][&quot;sh_be&quot;,&quot; should be &quot;]]</v></e><e t="2" f="196608"><n>lib_strings_en</n><v>[[&quot;row&quot;,&quot;row&quot;][&quot;rank&quot;,&quot;Rank&quot;][&quot;θdθn&quot;,&quot;θd diagonal and θn nilpotent&quot;][&quot;θw&quot;,&quot;Wronskian matrix (θw)&quot;][&quot;θsh&quot;,&quot;Solutions of X&apos;=A·X (θsh)&quot;][&quot;θse&quot;,&quot;Solutions of X&apos;=A·X + B  (θse)&quot;][&quot;dbl_chk&quot;,&quot;Let&apos;s double-check&quot;][&quot;eigenvals&quot;,&quot;Eigenvalue(s) :&quot;][&quot;eigensp_basis&quot;,&quot;Eigenspace basis :&quot;][&quot;rref_mλ&quot;,&quot;Row reduction form of M-λI: &quot;][&quot;is_diag&quot;,&quot;This matrix is diagonalizable&quot;][&quot;is_not_diag&quot;,&quot;This matrix is not diagonalizable&quot;][&quot;is_inv&quot;,&quot;This matrix is invertible&quot;][&quot;singular&quot;,&quot;This is a singular matrix&quot;][&quot;minpoly&quot;,&quot;Minimal polynomial&quot;][&quot;nilpotent&quot;,&quot;This is a nilpotent matrix&quot;][&quot;zeropwr&quot;,&quot;Powers are equal to 0 for&quot;][&quot;not_unique&quot;,&quot;This system doesn&apos;t have a unique solution&quot;][&quot;too_cplx&quot;,&quot;Error: formal parameter or too complex coefficient&quot;][&quot;not_square&quot;,&quot;Error: this is not a square matrix&quot;][&quot;symb_fail&quot;,&quot;Error: unable to compute exact eigenvalues&quot;][&quot;MAT&quot;,&quot;a matrix&quot;][&quot;POSINT&quot;,&quot;a positive integer&quot;][&quot;VAR&quot;,&quot;a symbolic var&quot;][&quot;NONE&quot;,&quot;a symbolic var&quot;][&quot;EXPR&quot;,&quot;an expression&quot;][&quot;STR&quot;,&quot;a string&quot;][&quot;SQM&quot;,&quot;a square matrix&quot;][&quot;VEC&quot;,&quot;a column vector&quot;][&quot;NUM&quot;,&quot;a rational number&quot;][&quot;SCAL&quot;,&quot;a number&quot;][&quot;INT_or_VAR&quot;,&quot;an integer or a symbolic var&quot;][&quot;different_rows_dims&quot;,&quot;Error: row dimensions of args do not match.&quot;][&quot;not_eg_val&quot;,&quot;This is not an eigenvalue.&quot;][&quot;use&quot;,&quot;Please use&quot;][&quot;before_use&quot;,&quot;before using this program&quot;][&quot;err_constructmat&quot;,&quot;First argument must be a string, for example, constructmat(&quot;&quot;i+j&quot;&quot;,3,3)&quot;][&quot;err&quot;,&quot;Error: &quot;][&quot;arg#&quot;,&quot;argument #&quot;][&quot;arg&quot;,&quot;argument&quot;][&quot;sh_be&quot;,&quot; should be &quot;][&quot;MatCons_required&quot;,&quot; must be a constant matrix&quot;][&quot;again&quot;,&quot;Just press ENTER to see another example&quot;]]</v></e><e t="2" f="196608"><n>lib_strings_fr</n><v>[[&quot;row&quot;,&quot;ligne&quot;][&quot;rank&quot;,&quot;Rang&quot;][&quot;θdθn&quot;,&quot;θd diagonale et θn nilpotente&quot;][&quot;θw&quot;,&quot;Matrice wronskienne (θw)&quot;][&quot;θsh&quot;,&quot;Solutions de X&apos;=A·X (θsh)&quot;][&quot;θse&quot;,&quot;Solutions de X&apos;=A·X + B  (θse)&quot;][&quot;dbl_chk&quot;,&quot;Vérifions&quot;][&quot;eigenvals&quot;,&quot;Valeur(s) propre(s) :&quot;][&quot;eigensp_basis&quot;,&quot;Base de l&apos;espace propre :&quot;][&quot;rref_mλ&quot;,&quot;Réduite de Gauss de M-λI: &quot;][&quot;is_diag&quot;,&quot;Cette matrice est diagonalisable&quot;][&quot;is_not_diag&quot;,&quot;Cette matrice n&apos;est pas diagonalisable&quot;][&quot;is_inv&quot;,&quot;Cette matrice est inversible&quot;][&quot;singular&quot;,&quot;Cette matrice n&apos;est pas inversible&quot;][&quot;minpoly&quot;,&quot;Polynôme minimal&quot;][&quot;nilpotent&quot;,&quot;Cette matrice est nilpotente&quot;][&quot;zeropwr&quot;,&quot;Les puissances sont nulles pour&quot;][&quot;not_unique&quot;,&quot;Ce système n&apos;a pas une solution unique&quot;][&quot;too_cplx&quot;,&quot;Erreur : paramètre formel, ou trop complexe&quot;][&quot;not_square&quot;,&quot;Erreur : ceci n&apos;est pas une matrice carrée&quot;][&quot;symb_fail&quot;,&quot;Erreur : les valeurs exactes des valeurs propres n&apos;ont pas pu être déterminées&quot;][&quot;MAT&quot;,&quot;une matrice&quot;][&quot;POSINT&quot;,&quot;un entier positif&quot;][&quot;VAR&quot;,&quot;une variable symbolique&quot;][&quot;NONE&quot;,&quot;une variable symbolique&quot;][&quot;EXPR&quot;,&quot;une expression&quot;][&quot;STR&quot;,&quot;une chaîne de caractères&quot;][&quot;SQM&quot;,&quot;une matrice carrée&quot;][&quot;VEC&quot;,&quot;un vecteur colonne&quot;][&quot;NUM&quot;,&quot;un nombre rationnel&quot;][&quot;SCAL&quot;,&quot;un nombre&quot;][&quot;INT_or_VAR&quot;,&quot;un entier ou une variable symbolique&quot;][&quot;different_rows_dims&quot;,&quot;Erreur : le nombre de lignes des arguments ne correspond pas.&quot;][&quot;not_eg_val&quot;,&quot;Ce n&apos;est pas une valeur propre.&quot;][&quot;use&quot;,&quot;Merci d&apos;utiliser&quot;][&quot;before_use&quot;,&quot;avant d&apos;utiliser ce programme&quot;][&quot;err_constructmat&quot;,&quot;Le premier argument doit être une chaîne, par exemple, constructmat(&quot;&quot;i+j&quot;&quot;,3,3)&quot;][&quot;err&quot;,&quot;Erreur : &quot;][&quot;arg#&quot;,&quot;l&apos;argument #&quot;][&quot;arg&quot;,&quot;l&apos;argument&quot;][&quot;sh_be&quot;,&quot; devrait être &quot;][&quot;MatCons_required&quot;,&quot; doit être une matrice constante&quot;][&quot;again&quot;,&quot;Appuyez sur la touche Entrée pour voir un autre exemple&quot;]]</v></e><e t="2" f="196608"><n>lib_strings_ge</n><v>[[&quot;row&quot;,&quot;Zeile&quot;][&quot;rank&quot;,&quot;Rang&quot;][&quot;θdθn&quot;,&quot;θd diagonal und θn nilpotent&quot;][&quot;θw&quot;,&quot;Wronski Matrix (θw)&quot;][&quot;θsh&quot;,&quot;Lösungen von X&apos;=A·X (θsh)&quot;][&quot;θse&quot;,&quot;Lösungen von X&apos;=A·X + B  (θse)&quot;][&quot;dbl_chk&quot;,&quot;Überprüfen&quot;][&quot;eigenvals&quot;,&quot;Eigenwert(e) : &quot;][&quot;eigensp_basis&quot;,&quot;Basis des Eigenraums : &quot;][&quot;rref_mλ&quot;,&quot;Gauss-reduzierte Form von M-λI: &quot;][&quot;is_diag&quot;,&quot;Diese Matrix ist diagonalisierbar&quot;][&quot;is_not_diag&quot;,&quot;Diese Matrix ist nicht diagonalisierbar&quot;][&quot;is_inv&quot;,&quot;Diese Matrix ist invertierbar&quot;][&quot;singular&quot;,&quot;Dies ist eine singuläre Matrix&quot;][&quot;minpoly&quot;,&quot;Minimal Polynom&quot;][&quot;nilpotent&quot;,&quot;Dies ist eine nilpotente Matrix&quot;][&quot;zeropwr&quot;,&quot;Potenzen sind gleich 0 für&quot;][&quot;not_unique&quot;,&quot;Dieses System hat keine eindeutige Lösung&quot;][&quot;too_cplx&quot;,&quot;Fehler: Formaler Parameter oder zu komlexer Koeffizient&quot;][&quot;not_square&quot;,&quot;Fehler: Dies ist keine quadratische Matrix&quot;][&quot;symb_fail&quot;,&quot;Fehler: Exakte Eigenwerte können nicht berechnet werden&quot;][&quot;MAT&quot;,&quot;eine Matrix&quot;][&quot;POSINT&quot;,&quot;eine positive Ganzzahl&quot;][&quot;VAR&quot;,&quot;eine symbolische Variable&quot;][&quot;NONE&quot;,&quot;eine symbolische Variable&quot;][&quot;EXPR&quot;,&quot;ein Ausdruck&quot;][&quot;STR&quot;,&quot;eine Zeichenkette&quot;][&quot;SQM&quot;,&quot;eine quadratische Matrix&quot;][&quot;VEC&quot;,&quot;ein Spaltennvektor&quot;][&quot;NUM&quot;,&quot;eine rationale Zahl&quot;][&quot;SCAL&quot;,&quot;eine Zahl&quot;][&quot;INT_or_VAR&quot;,&quot;eine Ganzzahl oder eine symbolische Variable&quot;][&quot;different_rows_dims&quot;,&quot;Fehler: Zeilendimension der Argumente passen nicht zusammen.&quot;][&quot;not_eg_val&quot;,&quot;Dies ist kein Eingenwert.&quot;][&quot;use&quot;,&quot;Bitte verwenden Sie&quot;][&quot;before_use&quot;,&quot;vor Anwenden dieses Programms&quot;][&quot;err_constructmat&quot;,&quot;Erstes Argument muss eine Zeichenkette sein, z.B., constructmat(&quot;&quot;i+j&quot;&quot;,3,3)&quot;][&quot;err&quot;,&quot;Fehler: &quot;][&quot;arg#&quot;,&quot;Argument #&quot;][&quot;arg&quot;,&quot;Argument&quot;][&quot;sh_be&quot;,&quot; sollte sein &quot;][&quot;MatCons_required&quot;,&quot; muss eine konstante Matrix sein&quot;][&quot;again&quot;,&quot;Just press ENTER to see another example&quot;]]</v></e><e t="6" f="65536"><n>rank</n><p>m</p><v>Func&#13;:©rank(Mat)&#13;:Local n,s&#13;:s:=check_type_arg(m,&quot;MAT&quot;,0)&#13;:If s≠&quot;ok&quot; Then&#13;:    s&#13;:Else&#13;:  n:=rref(m)&#13;:∑(when(norm(n[i])=0,0,1),i,1,rowDim(n))&#13;:EndIf&#13;:EndFunc</v></e><e t="7" f="65536"><n>simultstep</n><p>mat,vect</p><v>Prgm&#13;:©simultstep(aMat, bVect): step-by-step&#13;:Local i,k,c,m,nbl,nbc,matinv,s1,s2&#13;:s1:=check_type_arg(mat,&quot;SQM&quot;,1)&#13;:s2:=check_type_arg(vect,&quot;VEC&quot;,2)&#13;:If s1≠&quot;ok&quot; Then&#13;:   dispstring(s1)&#13;:ElseIf s2≠&quot;ok&quot; Then&#13;:   dispstring(s2)&#13;:ElseIf rowDim(mat)≠rowDim(vect) Then&#13;:   lib_msg(&quot;different_rows_dims&quot;,true)&#13;:Else&#13;: rowDim(mat)→nbl&#13;: colDim(mat)→nbc&#13;: If det(mat)=0 Then&#13;:   lib_msg(&quot;singular&quot;,true)&#13;: Else&#13;:   augment(mat,vect)→m&#13;:   Disp m&#13;:   gausstep(m)&#13;:   ©lib_msg(&quot;is_inv&quot;,true)&#13;:   For c,nbl,1,−1&#13;:     For i,c-1,1,−1&#13;:       If θmatg[i,c]≠0 Then&#13;:−θmatg[i,c]/(θmatg[c,c])→k&#13;:           gauss2(i,k,c)&#13;:       EndIf&#13;:     EndFor&#13;:   EndFor&#13;:   For i,1,nbl&#13;:    If θmatg[i,i]≠1 Then&#13;:        gauss2(i,1/(θmatg[i,i]),0)&#13;:    EndIf&#13;:   EndFor&#13;:   subMat(θmatg,1,nbc+1,nbl,nbc+1)→θsol&#13;:   Disp &quot;θsol=&quot;,θsol&#13;: EndIf&#13;:EndIf&#13;:EndPrgm</v></e></sym><card clay="0" h1="10000" h2="10000" w1="10000" w2="10000"><flag>0</flag><wdgt xmlns:np="urn:TI.Notepad" type="TI.Notepad" ver="1.0"><np:mFlags>0</np:mFlags><np:value>3</np:value><np:txt>\1keyword linalg\  \1keyword library\  \1keyword -\  \1keyword version\  \1keyword 2.00\  \1keyword (2008-05-08)\ 
\1subhead Philippe\  \1subhead Fortin\ 
\1subhead \ 
\1keyword How\  \1keyword to\  \1keyword use\  \1keyword this\  \1keyword library\ 
To use a function or program from this library, follow these steps: 
1. Make sure the library document linalg is in the MyLib folder.
2. Press [ctrl] [home] and select \1keyword Refresh\  \1keyword Libraries\ . 
3. Open the TI-Nspire™ application in which you want to use a function or program from the library. 
    \1subhead Note:\  \1subhead All\  \1subhead TI-Nspire™\  \1subhead applications\  \1subhead can\  \1subhead evaluate\  \1subhead functions,\  \1subhead but\  \1subhead only\  \1subhead the\  \1subhead Calculator\  \1subhead application\  \1subhead can\  \1subhead run\  \1subhead programs.\  
4. Open the Catalog and use the library tab to find and insert the object. 
    - or - 
    Type the name of the object, such as \0el {linalg\rank()}. To type the “\\” character on the handheld, press [CAPS] [÷]. 
5. If arguments are required, type them inside the parentheses.
    For example, \0el {linalg\rank([[1,2,3][4,5,6][7,8,9]])}
For more information about creating, editing, and using libraries, see the &quot;Libraries&quot; section of the documentation.
</np:txt></wdgt></card><card clay="0" h1="10000" h2="10000" w1="10000" w2="10000"><flag>0</flag><wdgt xmlns:np="urn:TI.Notepad" type="TI.Notepad" ver="1.0"><np:mFlags>0</np:mFlags><np:value>3</np:value><np:txt>\1keyword linalg\  \1keyword library\  \1keyword -\  \1keyword version\  \1keyword 2.00\  \1keyword (2008-05-08)\ 
======================
\1keyword Release\  \1keyword notes:\  \1keyword changes\  \1keyword from\  \1keyword version\  \1keyword 1.00\ 
This version is designed to work with the release 1.4 of TI-Nspire CAS
1 - trace and constructmat are now built-in standard functions. 
They have then be removed from this library.
2 - It is now possible to use the built-in function \0el {libShortcut()}, so def_shortcuts() &amp; del_shortcuts() have also been removed from this library.
3 - a new function allows the auto-detection of the language setting. Messages will automatically be displayed in English, French or German.
4 - New function: cofactor
======================
\1keyword TABLE\  \1keyword OF\  \1keyword CONTENTS\ 
\1keyword \ 
\1title Part1:\  \1title public\  \1title functions\ 
\1title \ \0el {clearmat()} - delete temporary matrices
\1keyword \ \0el {cofactor(Matrix,i,j)}  - cofactor of a matrix
\0el {gausstep(Matrix)} - step-by-step row matrix reduction.
\1keyword \ \0el {help()} - displays help for functions and programs from library linalg.
\0el {inversestep(Matrix)} - step-by-step matrix inverse computation.
\0el {kernelbasis(Matrix)} - basis of kernel (null space) of a matrix
\0el {rank(Matrix)} - rank of a matrix
\0el {simultstep(aMatrix, bVector)} - step-by-step version of simult().
    For example, \0el {simultstep([[1,2][3,4]],[[5][6]])} will solve system of linear equations: \0el {system(x+2y=5,3x+4y=6)}.
\1title Private\  \1title functions\  \1title used\  \1title internally\  \1title in\  \1title this\  \1title library\ 
-  \0el {check_type_arg}
- \0el { dispstring}
-  \0el {gauss1}
-  \0el {gauss2}
-  \0el {lib_msg}
-  \0el {lib_msg_en}
-  \0el {lib_msg_fr}
-  \0el {lib_msg_ge}
-  \0el {help_en}
-  \0el {help_fr}
-  \0el {help_ge}

\1title Private\  \1title variables\  \1title used\  \1title internally\  \1title in\  \1title this\  \1title library\ 
- \0el { lib_name}
- \0el { lib_strings_en}
- \0el { lib_strings_fr}
- \0el { lib_strings_ge}

\1title Text\  \1title messages\  
Column 2 of the matrices: \0el {lib_strings_en, lib_strings_fr, lib_strings_ge} </np:txt></wdgt></card></prob>