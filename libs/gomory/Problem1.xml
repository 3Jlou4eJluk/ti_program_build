<?xml version="1.0" encoding="UTF-8" ?><prob xmlns="urn:TI.Problem" ver="1.0"><sym><e t="6" f="65536" c="0"><n>version</n><p></p><v>Func&#13;:Return "3.0.5"&#13;:EndFunc</v></e><e t="6" f="65536" c="0"><n>gcd</n><p>a,b</p><v>Func&#13;:Local x,y,temp&#13;:abs(a)→x&#13;:abs(b)→y&#13;:While y&gt;0.0001&#13;:y→temp&#13;:mod(x,y)→y&#13;:temp→x&#13;:EndWhile&#13;:Return x&#13;:EndFunc</v></e><e t="6" f="65536" c="0"><n>modabs</n><p>y,d</p><v>Func&#13;:Local result&#13;:y-d*floor(y/d)→result&#13;:Return result&#13;:EndFunc</v></e><e t="6" f="65536" c="0"><n>findmu</n><p>beta,d</p><v>Func&#13;:Local mu,maxf,f,i,g&#13;:1→mu&#13;:0→maxf&#13;:For i,1,d-1&#13;:gcd(i,d)→g&#13;:If abs(g-1)&lt;0.0001 Then&#13;:modabs(i*beta,d)→f&#13;:If f&gt;maxf Then&#13;:f→maxf&#13;:i→mu&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:Return mu&#13;:EndFunc</v></e><e t="6" f="65536" c="0"><n>lcm2</n><p>a,b</p><v>Func&#13;:Local result&#13;:abs(a*b)/gcd(a,b)→result&#13;:Return result&#13;:EndFunc</v></e><e t="6" f="65536" c="0"><n>getdenom</n><p>x</p><v>Func&#13;:Local d&#13;:For d,1,1000&#13;:If abs(x*d-floor(x*d+0.5))&lt;0.0001 Then&#13;:Return d&#13;:EndIf&#13;:EndFor&#13;:Return 1&#13;:EndFunc</v></e><e t="7" f="65536" c="0"><n>gomory</n><p>mat,opt,intvars,ctypes</p><v>Prgm&#13;:Local m,n,i,j,k,tab,basis,iter,done,pcol,prow,piv,cutcnt,val,frac,cutrow,beta,dval,maxd,mu,f0,cutcoef,realvars,totalvars,slackvars,oldm&#13;:Disp "=== GOMORY v3.0 ==="&#13;:Disp " "&#13;:rowDim(mat)→m&#13;:colDim(mat)→n&#13;:m-1→m&#13;:n-1→n&#13;:Disp "--- TASK ---"&#13;:If opt=1 Then&#13;:Disp "max Z = "&#13;:Else&#13;:Disp "min Z = "&#13;:EndIf&#13;:For j,1,n&#13;:Disp "  c",j,"=",mat[m+1,j]&#13;:EndFor&#13;:Disp " "&#13;:Disp "Constraints: (types shown later)"&#13;:Disp " "&#13;:Disp "Integer vars:"&#13;:For j,1,n&#13;:If intvars[1,j]=1 Then&#13;:Disp "  x",j," - integer"&#13;:EndIf&#13;:EndFor&#13;:n→realvars&#13;:0→slackvars&#13;:For i,1,m&#13;:If ctypes[1,i]=1 Then&#13;:slackvars+1→slackvars&#13;:EndIf&#13;:If ctypes[1,i]=-1 Then&#13;:slackvars+2→slackvars&#13;:EndIf&#13;:If ctypes[1,i]=0 Then&#13;:slackvars+1→slackvars&#13;:EndIf&#13;:EndFor&#13;:realvars+slackvars→totalvars&#13;:newMat(m+1,totalvars+m+2)→tab&#13;:For i,1,m&#13;:For j,1,n&#13;:mat[i,j]→tab[i,j]&#13;:EndFor&#13;:EndFor&#13;:For i,1,m&#13;:mat[i,n+1]→tab[i,totalvars+m+2]&#13;:EndFor&#13;:For j,1,n&#13;:If opt=1 Then&#13;:-1*mat[m+1,j]→tab[m+1,j]&#13;:Else&#13;:mat[m+1,j]→tab[m+1,j]&#13;:EndIf&#13;:EndFor&#13;:newList(m)→basis&#13;:n+1→j&#13;:For i,1,m&#13;:If ctypes[1,i]=1 Then&#13;:1→tab[i,j]&#13;:j→basis[i]&#13;:j+1→j&#13;:EndIf&#13;:If ctypes[1,i]=-1 Then&#13;:-1→tab[i,j]&#13;:1→tab[i,j+1]&#13;:j+1→basis[i]&#13;:j+2→j&#13;:EndIf&#13;:If ctypes[1,i]=0 Then&#13;:1→tab[i,j]&#13;:j→basis[i]&#13;:j+1→j&#13;:EndIf&#13;:EndFor&#13;:Disp " "&#13;:Disp "--- CANONICAL FORM ---"&#13;:Disp "Initial basis:"&#13;:For i,1,m&#13;:Disp "  row",i,": x",basis[i],"=",tab[i,totalvars+m+2]&#13;:EndFor&#13;:Disp " "&#13;:Disp "--- SIMPLEX TABLE ---"&#13;:For i,1,m&#13;:Disp "Row",i,"(x",basis[i],"):"&#13;:For j,1,n&#13;:Disp "  a",j,"=",tab[i,j]&#13;:EndFor&#13;:Disp "  b=",tab[i,totalvars+m+2]&#13;:EndFor&#13;:0→iter&#13;:false→done&#13;:Disp " "&#13;:Disp "PHASE 1: Find feasible"&#13;:While not done and iter&lt;30&#13;:iter+1→iter&#13;:0→pcol&#13;:For j,1,totalvars&#13;:If pcol=0 and tab[m+1,j]&lt;-0.0001 Then&#13;:j→pcol&#13;:EndIf&#13;:EndFor&#13;:If pcol=0 Then&#13;:true→done&#13;:Else&#13;:0→prow&#13;:1000000→val&#13;:For i,1,m&#13;:If tab[i,pcol]&gt;0.0001 Then&#13;:tab[i,totalvars+m+2]/tab[i,pcol]→frac&#13;:If frac&gt;=0 and frac&lt;val Then&#13;:frac→val&#13;:i→prow&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If prow=0 Then&#13;:0→val&#13;:-1000000→frac&#13;:For i,1,m&#13;:If tab[i,totalvars+m+2]&lt;-0.0001 Then&#13;:If tab[i,totalvars+m+2]&lt;frac Then&#13;:tab[i,totalvars+m+2]→frac&#13;:i→prow&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:EndIf&#13;:If prow=0 Then&#13;:Disp "Unbounded in Phase 1"&#13;:Return&#13;:EndIf&#13;:Disp "Iter",iter,": x",pcol,"enters, x",basis[prow],"leaves"&#13;:tab[prow,pcol]→piv&#13;:For j,1,totalvars+m+2&#13;:tab[prow,j]/piv→tab[prow,j]&#13;:EndFor&#13;:For i,1,m+1&#13;:If i≠prow Then&#13;:tab[i,pcol]→val&#13;:For j,1,totalvars+m+2&#13;:tab[i,j]-val*tab[prow,j]→tab[i,j]&#13;:EndFor&#13;:EndIf&#13;:EndFor&#13;:pcol→basis[prow]&#13;:EndIf&#13;:EndWhile&#13;:If iter&gt;=30 Then&#13;:Disp "Phase 1: max iter"&#13;:Return&#13;:EndIf&#13;:Disp "Phase 1 done, iter=",iter&#13;:Disp "Basis:"&#13;:For i,1,m&#13;:Disp "  x",basis[i],"=",tab[i,totalvars+m+2]&#13;:EndFor&#13;:For j,1,n&#13;:If opt=1 Then&#13;:-1*mat[m+1,j]→tab[m+1,j]&#13;:Else&#13;:mat[m+1,j]→tab[m+1,j]&#13;:EndIf&#13;:EndFor&#13;:For j,n+1,totalvars+m+1&#13;:0→tab[m+1,j]&#13;:EndFor&#13;:0→tab[m+1,totalvars+m+2]&#13;:For i,1,m&#13;:tab[m+1,basis[i]]→val&#13;:If abs(val)&gt;0.0001 Then&#13;:For j,1,totalvars+m+2&#13;:tab[m+1,j]-val*tab[i,j]→tab[m+1,j]&#13;:EndFor&#13;:EndIf&#13;:EndFor&#13;:0→iter&#13;:false→done&#13;:Disp " "&#13;:Disp "PHASE 2: Optimize"&#13;:While not done and iter&lt;30&#13;:iter+1→iter&#13;:0→pcol&#13;:For j,1,totalvars&#13;:If pcol=0 and tab[m+1,j]&lt;-0.0001 Then&#13;:j→pcol&#13;:EndIf&#13;:EndFor&#13;:If pcol=0 Then&#13;:true→done&#13;:Else&#13;:0→prow&#13;:1000000→val&#13;:For i,1,m&#13;:If tab[i,pcol]&gt;0.0001 Then&#13;:tab[i,totalvars+m+2]/tab[i,pcol]→frac&#13;:If frac&lt;val Then&#13;:frac→val&#13;:i→prow&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If prow=0 Then&#13;:Disp "Unbounded in Phase 2"&#13;:Return&#13;:EndIf&#13;:Disp "Iter",iter,": x",pcol,"enters, x",basis[prow],"leaves"&#13;:tab[prow,pcol]→piv&#13;:For j,1,totalvars+m+2&#13;:tab[prow,j]/piv→tab[prow,j]&#13;:EndFor&#13;:For i,1,m+1&#13;:If i≠prow Then&#13;:tab[i,pcol]→val&#13;:For j,1,totalvars+m+2&#13;:tab[i,j]-val*tab[prow,j]→tab[i,j]&#13;:EndFor&#13;:EndIf&#13;:EndFor&#13;:pcol→basis[prow]&#13;:EndIf&#13;:EndWhile&#13;:If iter&gt;=30 Then&#13;:Disp "Phase 2: max iter"&#13;:Return&#13;:EndIf&#13;:Disp "Phase 2 done, iter=",iter&#13;:Disp "Basis:"&#13;:For i,1,m&#13;:Disp "  row",i,": x",basis[i],"=",tab[i,totalvars+m+2]&#13;:EndFor&#13;:Disp "DEBUG: totalvars=",totalvars&#13;:Disp "DEBUG: RHS col=",totalvars+m+2&#13;:Disp " "&#13;:Disp "--- LP SOLUTION ---"&#13;:Disp "Z* =",tab[m+1,totalvars+m+2]&#13;:Disp " "&#13;:Disp "All variables:"&#13;:For j,1,totalvars&#13;:0→val&#13;:For i,1,m&#13;:If basis[i]=j Then&#13;:tab[i,totalvars+m+2]→val&#13;:EndIf&#13;:EndFor&#13;:Disp "  x",j,"=",val&#13;:EndFor&#13;:0→cutcnt&#13;:false→done&#13;:While not done and cutcnt&lt;20&#13;:Local rhsc&#13;:colDim(tab)→rhsc&#13;:Disp " "&#13;:Disp "--- INTEGRALITY CHECK ---"&#13;:For j,1,n&#13;:If intvars[1,j]=1 Then&#13;:0→val&#13;:For i,1,m&#13;:If basis[i]=j Then&#13;:tab[i,rhsc]→val&#13;:EndIf&#13;:EndFor&#13;:val-floor(val)→frac&#13;:If frac&gt;0.0001 and frac&lt;0.9999 Then&#13;:Disp "x",j,"=",val," FRAC!"&#13;:Else&#13;:Disp "x",j,"=",val," OK"&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:Disp " "&#13;:0→cutrow&#13;:0→f0&#13;:For i,1,m&#13;:If basis[i]&lt;=realvars Then&#13;:If intvars[1,basis[i]]=1 Then&#13;:tab[i,rhsc]→val&#13;:val-floor(val)→frac&#13;:If frac&gt;0.0001 and frac&lt;0.9999 Then&#13;:If frac&gt;f0 Then&#13;:frac→f0&#13;:i→cutrow&#13;:tab[i,rhsc]→beta&#13;:EndIf&#13;:EndIf&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If cutrow=0 Then&#13;:true→done&#13;:Disp " "&#13;:Disp "=== ANSWER ==="&#13;:Disp "Optimal integer found!"&#13;:Disp " "&#13;:Disp "Z* =",tab[rowDim(tab),rhsc]&#13;:Disp " "&#13;:Disp "Solution:"&#13;:For j,1,n&#13;:0→val&#13;:For i,1,m&#13;:If basis[i]=j Then&#13;:tab[i,rhsc]→val&#13;:EndIf&#13;:EndFor&#13;:Disp "  x",j,"=",val&#13;:EndFor&#13;:Disp " "&#13;:Disp "Cuts used:",cutcnt&#13;:Return&#13;:EndIf&#13;:Disp "=== GOMORY CUT #",cutcnt+1," ==="&#13;:Disp "Source row:",cutrow,"x",basis[cutrow]&#13;:Disp "beta =",beta&#13;:Disp "f0 =",f0&#13;:Disp " "&#13;:Disp "Cut coefficients:"&#13;:m→oldm&#13;:Local oldtab,oldrows,oldcols&#13;:tab→oldtab&#13;:rowDim(oldtab)→oldrows&#13;:colDim(oldtab)→oldcols&#13;:newMat(oldrows+1,oldcols+1)→tab&#13;:For i,1,oldm&#13;:For j,1,oldcols-1&#13;:oldtab[i,j]→tab[i,j]&#13;:EndFor&#13;:0→tab[i,oldcols]&#13;:oldtab[i,oldcols]→tab[i,oldcols+1]&#13;:EndFor&#13;:For j,1,oldcols-1&#13;:oldtab[oldm+1,j]→tab[oldm+2,j]&#13;:EndFor&#13;:0→tab[oldm+2,oldcols]&#13;:oldtab[oldm+1,oldcols]→tab[oldm+2,oldcols+1]&#13;:For j,1,oldcols-1&#13;:oldtab[cutrow,j]→val&#13;:val-floor(val)→frac&#13;:If frac&gt;0.9999 Then&#13;:0→frac&#13;:EndIf&#13;:-1*frac→tab[oldm+1,j]&#13;:If frac&gt;0.0001 Then&#13;:Disp "  f",j,"=",frac&#13;:EndIf&#13;:EndFor&#13;:1→tab[oldm+1,oldcols]&#13;:-1*f0→tab[oldm+1,oldcols+1]&#13;:augment(basis,{oldcols})→basis&#13;:m+1→m&#13;:cutcnt+1→cutcnt&#13;:Disp " "&#13;:Disp "Cut equation:"&#13;:Disp "  Sum(frac(a_j)*x_j) &gt;= ",f0&#13;:Disp " "&#13;:Disp "DUAL SIMPLEX..."&#13;:Local dualrhsc&#13;:colDim(tab)→dualrhsc&#13;:0→iter&#13;:false→done&#13;:While not done and iter&lt;30&#13;:iter+1→iter&#13;:0→prow&#13;:For i,1,m&#13;:If tab[i,dualrhsc]&lt;-0.0001 Then&#13;:i→prow&#13;:Goto dualfound&#13;:EndIf&#13;:EndFor&#13;:Lbl dualfound&#13;:If prow=0 Then&#13;:true→done&#13;:Else&#13;:0→pcol&#13;:1000000→val&#13;:For j,1,dualrhsc-1&#13;:If tab[prow,j]&lt;-0.0001 Then&#13;:abs(tab[rowDim(tab),j]/tab[prow,j])→frac&#13;:If frac&lt;val Then&#13;:frac→val&#13;:j→pcol&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If pcol=0 Then&#13;:Disp "Infeasible after cut"&#13;:Return&#13;:EndIf&#13;:Disp "Pivot: row",prow,"col",pcol&#13;:tab[prow,pcol]→piv&#13;:For j,1,dualrhsc&#13;:tab[prow,j]/piv→tab[prow,j]&#13;:EndFor&#13;:For i,1,rowDim(tab)&#13;:If i≠prow Then&#13;:tab[i,pcol]→val&#13;:For j,1,dualrhsc&#13;:tab[i,j]-val*tab[prow,j]→tab[i,j]&#13;:EndFor&#13;:EndIf&#13;:EndFor&#13;:pcol→basis[prow]&#13;:EndIf&#13;:EndWhile&#13;:If iter&gt;=30 Then&#13;:Disp "Dual simplex: max iter"&#13;:Return&#13;:EndIf&#13;:Disp "Dual done, iter=",iter&#13;:false→done&#13;:Disp " "&#13;:Disp "Current solution:"&#13;:Local rhscol&#13;:colDim(tab)→rhscol&#13;:Disp "  Z =",tab[rowDim(tab),rhscol]&#13;:For j,1,n&#13;:0→val&#13;:For i,1,m&#13;:If basis[i]=j Then&#13;:tab[i,rhscol]→val&#13;:EndIf&#13;:EndFor&#13;:Disp "  x",j,"=",val&#13;:EndFor&#13;:EndWhile&#13;:If cutcnt&gt;=20 Then&#13;:Disp "Max cuts reached"&#13;:EndIf&#13;:EndPrgm</v></e><e t="7" f="65536" c="0"><n>help</n><p></p><v>Prgm&#13;:Disp "gomory library v3.0.0"&#13;:Disp " "&#13;:Disp "New: Lecture version"&#13;:Disp "- Optimal mu selection"&#13;:Disp "- Z-row cuts"&#13;:Disp " "&#13;:Disp "gomory(mat,opt,intvars,ctypes)"&#13;:Disp "  mat: [[A|b][c|0]]"&#13;:Disp "  opt: 1=max, 0=min"&#13;:Disp "  intvars: [1,1,1]"&#13;:Disp "  ctypes: [1,-1,0]"&#13;:Disp "    1=&lt;=, -1=&gt;=, 0=="&#13;:Disp " "&#13;:Disp "gcd(a,b) - GCD"&#13;:EndPrgm</v></e></sym><card clay="0" h1="10000" h2="10000" w1="10000" w2="10000"><flag>0</flag><wdgt xmlns:np="urn:TI.Notepad" type="TI.Notepad" ver="1.0"><np:mFlags>0</np:mFlags><np:value>3</np:value><np:txt>\1keyword gomory\  \1keyword library\  \1keyword -\  \1keyword version\  \1keyword 3.0.0\
\1subhead Gomory\  \1subhead (Lecture\  \1subhead version)\
\1subhead \
\1keyword New\  \1keyword in\  \1keyword v3.0\
- Optimal mu selection (findmu)
- Z-row cuts (objective function cuts)
- Generalized cut formula from lecture

\1keyword Functions:\
- gcd(a,b) - greatest common divisor
- modabs(y,d) - |y|_D modulo
- findmu(beta,d) - optimal mu
- lcmlist(lst) - LCM of list (for D)
- gomory(mat,opt,intvars,ctypes) - main

</np:txt></wdgt></card></prob>
