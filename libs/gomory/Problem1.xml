<?xml version="1.0" encoding="UTF-8" ?><prob xmlns="urn:TI.Problem" ver="1.0"><sym><e t="6" f="65536" c="0"><n>version</n><p></p><v>Func&#13;:Return "2.2.0"&#13;:EndFunc</v></e><e t="7" f="65536" c="0"><n>gomory</n><p>mat,opt,intvars,ctypes</p><v>Prgm&#13;:Local m,n,a,b,c,i,j,k,tab,mult,pcol,prow,minval,minrat,done,iter,cnt,row,val&#13;:Disp "=== GOMORY v2.2 ==="&#13;:Disp " "&#13;:Disp "==="&#13;:Disp "ORIGINAL PROBLEM"&#13;:Disp "==="&#13;:Disp " "&#13;:rowDim(mat)→m&#13;:colDim(mat)→n&#13;:m-1→m&#13;:n-1→n&#13;:Local origctypes&#13;:newList(m)→origctypes&#13;:For i,1,m&#13;:ctypes[1,i]→origctypes[i]&#13;:EndFor&#13;:If opt=1 Then&#13;:Disp "Objective: maximize Z"&#13;:Else&#13;:Disp "Objective: minimize Z"&#13;:EndIf&#13;:Disp " "&#13;:Disp "Objective function:"&#13;:For j,1,n&#13;:Disp "  c"&amp;string(j)&amp;"=",mat[m+1,j]&#13;:EndFor&#13;:Disp " "&#13;:Disp "Constraints:"&#13;:For i,1,m&#13;:Disp "Row",i,":"&#13;:For j,1,n&#13;:Disp "  a"&amp;string(i)&amp;string(j)&amp;"=",mat[i,j]&#13;:EndFor&#13;:Disp "  b"&amp;string(i)&amp;"=",mat[i,n+1]&#13;:If ctypes[1,i]=1 Then&#13;:Disp "  type: &lt;="&#13;:ElseIf ctypes[1,i]=-1 Then&#13;:Disp "  type: &gt;="&#13;:Else&#13;:Disp "  type: ="&#13;:EndIf&#13;:EndFor&#13;:Disp " "&#13;:Disp "Integer variables:"&#13;:For j,1,n&#13;:If intvars[1,j]=1 Then&#13;:Disp "  x"&amp;string(j)&amp;" - integer"&#13;:EndIf&#13;:EndFor&#13;:Disp " "&#13;:subMat(mat,1,1,m,n)→a&#13;:subMat(mat,1,n+1,m,n+1)→b&#13;:subMat(mat,m+1,1,m+1,n)→c&#13;:For i,1,m&#13;:If b[i,1]&lt;0 Then&#13;:For j,1,n&#13;:-1*a[i,j]→a[i,j]&#13;:EndFor&#13;:-1*b[i,1]→b[i,1]&#13;:If ctypes[1,i]=-1 Then&#13;:1→ctypes[1,i]&#13;:ElseIf ctypes[1,i]=1 Then&#13;:-1→ctypes[1,i]&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:Local optmult&#13;:If opt=0 Then&#13;:-1→optmult&#13;:Else&#13;:1→optmult&#13;:EndIf&#13;:Local nart,nsurp,nslack,needphase1,newtab&#13;:0→nart&#13;:0→nsurp&#13;:0→nslack&#13;:false→needphase1&#13;:For i,1,m&#13;:If ctypes[1,i]=1 Then&#13;:nslack+1→nslack&#13;:ElseIf ctypes[1,i]=-1 Then&#13;:nsurp+1→nsurp&#13;:nart+1→nart&#13;:true→needphase1&#13;:Else&#13;:nart+1→nart&#13;:true→needphase1&#13;:EndIf&#13;:EndFor&#13;:Disp "---"&#13;:Disp "CANONICAL FORM"&#13;:Disp "---"&#13;:Disp "Slack vars:",nslack&#13;:Disp "Surplus vars:",nsurp&#13;:Disp "Artificial vars:",nart&#13;:Local ncols,spos,apos&#13;:n+nslack+nsurp+nart→ncols&#13;:Disp "Total vars:",ncols&#13;:Disp " "&#13;:newMat(m+1,ncols+1)→tab&#13;:For i,1,m&#13;:For j,1,n&#13;:a[i,j]→tab[i,j]&#13;:EndFor&#13;:EndFor&#13;:For i,1,m&#13;:b[i,1]→tab[i,ncols+1]&#13;:EndFor&#13;:0→spos&#13;:0→apos&#13;:For i,1,m&#13;:If ctypes[1,i]=1 Then&#13;:n+1+spos→j&#13;:1→tab[i,j]&#13;:spos+1→spos&#13;:ElseIf ctypes[1,i]=-1 Then&#13;:n+1+spos→j&#13;:-1→tab[i,j]&#13;:spos+1→spos&#13;:n+nslack+nsurp+1+apos→j&#13;:1→tab[i,j]&#13;:apos+1→apos&#13;:Else&#13;:n+nslack+nsurp+1+apos→j&#13;:1→tab[i,j]&#13;:apos+1→apos&#13;:EndIf&#13;:EndFor&#13;:If needphase1 Then&#13;:Disp "PHASE 1: Minimize artificial"&#13;:For j,1,n+nslack+nsurp&#13;:0→tab[m+1,j]&#13;:EndFor&#13;:For j,n+nslack+nsurp+1,ncols&#13;:-1→tab[m+1,j]&#13;:EndFor&#13;:0→tab[m+1,ncols+1]&#13;:For i,1,m&#13;:If ctypes[1,i]=-1 or ctypes[1,i]=0 Then&#13;:For j,1,ncols+1&#13;:tab[m+1,j]+tab[i,j]→tab[m+1,j]&#13;:EndFor&#13;:EndIf&#13;:EndFor&#13;:Disp " "&#13;:Disp "Initial Phase 1 tableau:"&#13;:Disp tab&#13;:Disp " "&#13;:0→iter&#13;:false→done&#13;:While not done and iter&lt;20&#13;:iter+1→iter&#13;:rowDim(tab)→mult&#13;:colDim(tab)→pcol&#13;:0→minval&#13;:0→j&#13;:For k,1,pcol-1&#13;:If tab[mult,k]&gt;minval Then&#13;:tab[mult,k]→minval&#13;:k→j&#13;:EndIf&#13;:EndFor&#13;:If j=0 Then&#13;:Disp "Phase 1 optimal"&#13;:true→done&#13;:Else&#13;:Disp "=== P1 ITERATION ",iter," ==="&#13;:Disp "Entering var: x"&amp;string(j)&#13;:9999→minrat&#13;:0→prow&#13;:For i,1,mult-1&#13;:If tab[i,j]&gt;0.000001 Then&#13;:tab[i,pcol]/tab[i,j]→minval&#13;:If minval&lt;minrat Then&#13;:minval→minrat&#13;:i→prow&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If prow=0 Then&#13;:Disp "No feasible solution"&#13;:Return&#13;:Else&#13;:Disp "Leaving var: row ",prow&#13;:Disp "Pivot element:",tab[prow,j]&#13;:Disp " "&#13;:tab[prow,j]→minval&#13;:For k,1,pcol&#13;:tab[prow,k]/minval→tab[prow,k]&#13;:EndFor&#13;:For i,1,mult&#13;:If i≠prow Then&#13;:tab[i,j]→minval&#13;:For k,1,pcol&#13;:tab[i,k]-minval*tab[prow,k]→tab[i,k]&#13;:EndFor&#13;:EndIf&#13;:EndFor&#13;:Disp "Tableau after pivot:"&#13;:Disp tab&#13;:Disp " "&#13;:EndIf&#13;:EndIf&#13;:EndWhile&#13;:If abs(tab[mult,pcol])&gt;0.0001 Then&#13;:Disp "No feasible solution"&#13;:Return&#13;:EndIf&#13;:newMat(mult,n+nslack+nsurp+1)→newtab&#13;:For i,1,mult-1&#13;:For k,1,n+nslack+nsurp&#13;:tab[i,k]→newtab[i,k]&#13;:EndFor&#13;:tab[i,pcol]→newtab[i,n+nslack+nsurp+1]&#13;:EndFor&#13;:rowDim(mat)→m&#13;:colDim(mat)→n&#13;:m-1→m&#13;:n-1→n&#13;:For k,1,n&#13;:-1*optmult*mat[m+1,k]→newtab[mult,k]&#13;:EndFor&#13;:For k,n+1,n+nslack+nsurp&#13;:0→newtab[mult,k]&#13;:EndFor&#13;:0→newtab[mult,n+nslack+nsurp+1]&#13;:For i,1,mult-1&#13;:For k,1,n+nslack+nsurp&#13;:If abs(newtab[i,k]-1)&lt;0.0001 Then&#13;:0→cnt&#13;:For j,1,mult-1&#13;:If j≠i and abs(newtab[j,k])&gt;0.0001 Then&#13;:cnt+1→cnt&#13;:EndIf&#13;:EndFor&#13;:If cnt=0 Then&#13;:newtab[mult,k]→val&#13;:For j,1,n+nslack+nsurp+1&#13;:newtab[mult,j]-val*newtab[i,j]→newtab[mult,j]&#13;:EndFor&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:EndFor&#13;:newtab→tab&#13;:Else&#13;:rowDim(mat)→m&#13;:colDim(mat)→n&#13;:m-1→m&#13;:n-1→n&#13;:For k,1,n&#13;:-1*optmult*mat[m+1,k]→tab[m+1,k]&#13;:EndFor&#13;:For k,n+1,ncols&#13;:0→tab[m+1,k]&#13;:EndFor&#13;:0→tab[m+1,ncols+1]&#13;:EndIf&#13;:Disp "PHASE 2: Original objective"&#13;:Disp " "&#13;:Disp "Initial Phase 2 tableau:"&#13;:Disp tab&#13;:Disp " "&#13;:0→iter&#13;:false→done&#13;:While not done and iter&lt;20&#13;:iter+1→iter&#13;:rowDim(tab)→mult&#13;:colDim(tab)→pcol&#13;:0→minval&#13;:0→j&#13;:For k,1,pcol-1&#13;:If tab[mult,k]&lt;minval Then&#13;:tab[mult,k]→minval&#13;:k→j&#13;:EndIf&#13;:EndFor&#13;:If j=0 Then&#13;:Disp "Phase 2 optimal"&#13;:Disp " "&#13;:true→done&#13;:Else&#13;:Disp "=== P2 ITERATION ",iter," ==="&#13;:Disp "Entering var: x"&amp;string(j)&#13;:9999→minrat&#13;:0→prow&#13;:For i,1,mult-1&#13;:If tab[i,j]&gt;0.000001 Then&#13;:tab[i,pcol]/tab[i,j]→minval&#13;:If minval&lt;minrat Then&#13;:minval→minrat&#13;:i→prow&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If prow=0 Then&#13;:Disp "UNBOUNDED"&#13;:Return&#13;:Else&#13;:Disp "Leaving var: row ",prow&#13;:Disp "Pivot element:",tab[prow,j]&#13;:Disp " "&#13;:tab[prow,j]→minval&#13;:For k,1,pcol&#13;:tab[prow,k]/minval→tab[prow,k]&#13;:EndFor&#13;:For i,1,mult&#13;:If i≠prow Then&#13;:tab[i,j]→minval&#13;:For k,1,pcol&#13;:tab[i,k]-minval*tab[prow,k]→tab[i,k]&#13;:EndFor&#13;:EndIf&#13;:EndFor&#13;:Disp "Tableau after pivot:"&#13;:Disp tab&#13;:Disp " "&#13;:EndIf&#13;:EndIf&#13;:EndWhile&#13;:Disp "---"&#13;:Disp "LP RELAXATION SOLUTION"&#13;:Disp "---"&#13;:rowDim(tab)→mult&#13;:colDim(tab)→pcol&#13;:Disp "Z =",tab[mult,pcol]&#13;:rowDim(mat)→m&#13;:colDim(mat)→n&#13;:m-1→m&#13;:n-1→n&#13;:For j,1,n&#13;:0→val&#13;:0→cnt&#13;:0→row&#13;:For i,1,mult-1&#13;:If abs(tab[i,j])&gt;0.0001 Then&#13;:cnt+1→cnt&#13;:If abs(tab[i,j]-1)&lt;0.0001 Then&#13;:i→row&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If cnt=1 and row&gt;0 Then&#13;:tab[row,pcol]→val&#13;:EndIf&#13;:Local frac&#13;:val-floor(val)→frac&#13;:If intvars[1,j]=1 and frac&gt;0.0001 and frac&lt;0.9999 Then&#13;:Disp "x"&amp;string(j)&amp;"=",val," &lt;- fractional"&#13;:Else&#13;:Disp "x"&amp;string(j)&amp;"=",val&#13;:EndIf&#13;:EndFor&#13;:Disp " "&#13;:Local ncuts,intdone&#13;:0→ncuts&#13;:false→intdone&#13;:While not intdone and ncuts&lt;10&#13;:Disp " "&#13;:Disp "=== CUT ",ncuts+1," ==="&#13;:Disp "---"&#13;:Disp "INTEGRALITY CHECK"&#13;:Disp "---"&#13;:rowDim(mat)→m&#13;:colDim(mat)→n&#13;:m-1→m&#13;:n-1→n&#13;:rowDim(tab)→mult&#13;:colDim(tab)→pcol&#13;:Local isint,val,frac,cnt,row&#13;:true→isint&#13;:For j,1,n&#13;:0→val&#13;:0→cnt&#13;:0→row&#13;:For i,1,mult-1&#13;:If abs(tab[i,j])&gt;0.0001 Then&#13;:cnt+1→cnt&#13;:If abs(tab[i,j]-1)&lt;0.0001 Then&#13;:i→row&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If cnt=1 and row&gt;0 Then&#13;:tab[row,pcol]→val&#13;:EndIf&#13;:Disp "x"&amp;string(j)&amp;"=",val&#13;:val-floor(val)→frac&#13;:If intvars[1,j]=1 Then&#13;:If frac&gt;0.0001 and frac&lt;0.9999 Then&#13;:false→isint&#13;:Disp "  FRACTIONAL!"&#13;:Else&#13;:Disp "  OK"&#13;:EndIf&#13;:Else&#13;:Disp "  (continuous)"&#13;:EndIf&#13;:EndFor&#13;:Disp " "&#13;:If isint Then&#13;:Disp "Conclusion: All integer!"&#13;:Else&#13;:Disp "Conclusion: Gomory cut required"&#13;:EndIf&#13;:Disp " "&#13;:If isint Then&#13;:Disp "==="&#13;:Disp "OPTIMAL INTEGER SOLUTION"&#13;:Disp "==="&#13;:Disp " "&#13;:Disp "Optimal plan:"&#13;:rowDim(mat)→m&#13;:colDim(mat)→n&#13;:m-1→m&#13;:n-1→n&#13;:For j,1,n&#13;:0→val&#13;:0→cnt&#13;:0→row&#13;:For i,1,mult-1&#13;:If abs(tab[i,j])&gt;0.0001 Then&#13;:cnt+1→cnt&#13;:If abs(tab[i,j]-1)&lt;0.0001 Then&#13;:i→row&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If cnt=1 and row&gt;0 Then&#13;:tab[row,pcol]→val&#13;:EndIf&#13;:Disp "  x"&amp;string(j)&amp;"* =",val&#13;:EndFor&#13;:Disp " "&#13;:Disp "Objective value:"&#13;:Disp "  Z* =",tab[mult,pcol]&#13;:Disp " "&#13;:Disp "Verification:"&#13;:Local xvals,lhs,rhs,satisfied&#13;:newList(n)→xvals&#13;:For j,1,n&#13;:0→val&#13;:0→cnt&#13;:0→row&#13;:For i,1,mult-1&#13;:If abs(tab[i,j])&gt;0.0001 Then&#13;:cnt+1→cnt&#13;:If abs(tab[i,j]-1)&lt;0.0001 Then&#13;:i→row&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If cnt=1 and row&gt;0 Then&#13;:tab[row,pcol]→val&#13;:EndIf&#13;:val→xvals[j]&#13;:EndFor&#13;:For i,1,m&#13;:0→lhs&#13;:For j,1,n&#13;:lhs+mat[i,j]*xvals[j]→lhs&#13;:EndFor&#13;:mat[i,n+1]→rhs&#13;:Disp " Constr",i,":"&#13;:Disp "  LHS=",lhs&#13;:Disp "  RHS=",rhs&#13;:true→satisfied&#13;:If origctypes[i]=1 Then&#13;:If lhs&lt;=rhs+0.001 Then&#13;:Disp "  ",lhs,"&lt;=",rhs,"OK"&#13;:Else&#13;:Disp "  ",lhs,"&gt;",rhs,"ERROR!"&#13;:false→satisfied&#13;:EndIf&#13;:ElseIf origctypes[i]=-1 Then&#13;:If lhs&gt;=rhs-0.001 Then&#13;:Disp "  ",lhs,"&gt;=",rhs,"OK"&#13;:Else&#13;:Disp "  ",lhs,"&lt;",rhs,"ERROR!"&#13;:false→satisfied&#13;:EndIf&#13;:Else&#13;:If abs(lhs-rhs)&lt;0.001 Then&#13;:Disp "  ",lhs,"=",rhs,"OK"&#13;:Else&#13;:Disp "  ",lhs,"≠",rhs,"ERROR!"&#13;:false→satisfied&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:Disp " "&#13;:Disp "Gomory cuts used:",ncuts&#13;:true→intdone&#13;:Else&#13;:Disp "Solution not integer"&#13;:Disp "==="&#13;:Disp "GOMORY CUT"&#13;:Disp "==="&#13;:Local maxfrac,cutrow&#13;:0→maxfrac&#13;:0→cutrow&#13;:For i,1,mult-1&#13;:For j,1,n&#13;:If intvars[1,j]=1 Then&#13;:0→cnt&#13;:0→row&#13;:For k,1,mult-1&#13;:If abs(tab[k,j])&gt;0.0001 Then&#13;:cnt+1→cnt&#13;:If abs(tab[k,j]-1)&lt;0.0001 Then&#13;:k→row&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If cnt=1 and row=i Then&#13;:tab[i,pcol]→val&#13;:val-floor(val)→frac&#13;:If frac&gt;maxfrac Then&#13;:frac→maxfrac&#13;:i→cutrow&#13;:EndIf&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:EndFor&#13;:Disp "Row ",cutrow," selected"&#13;:Disp "(max frac =",maxfrac,")"&#13;:Disp " "&#13;:Disp "Source row ",cutrow,":"&#13;:Disp tab[cutrow]&#13;:Disp " "&#13;:Disp "Fractional parts:"&#13;:Disp "(for Gomory cut formula)"&#13;:Local cutrow_data,k&#13;:newList(pcol)→cutrow_data&#13;:For k,1,pcol-1&#13;:tab[cutrow,k]→val&#13;:val-floor(val)→frac&#13;:-1*frac→cutrow_data[k]&#13;:Disp "  f("&amp;string(k)&amp;")=",frac&#13;:EndFor&#13;:tab[cutrow,pcol]→val&#13;:val-floor(val)→frac&#13;:-1*frac→cutrow_data[pcol]&#13;:Disp "  f(RHS)=",frac&#13;:Disp " "&#13;:Disp "Gomory cut (canonical form):"&#13;:Disp cutrow_data&#13;:Disp "(added slack variable)"&#13;:Disp " "&#13;:Local newtab,nr,nc&#13;:mult+1→nr&#13;:pcol+1→nc&#13;:newMat(nr,nc)→newtab&#13;:For i,1,mult-1&#13;:For k,1,pcol-1&#13;:tab[i,k]→newtab[i,k]&#13;:EndFor&#13;:0→newtab[i,pcol]&#13;:tab[i,pcol]→newtab[i,nc]&#13;:EndFor&#13;:For k,1,pcol-1&#13;:cutrow_data[k]→newtab[mult,k]&#13;:EndFor&#13;:1→newtab[mult,pcol]&#13;:cutrow_data[pcol]→newtab[mult,nc]&#13;:For k,1,pcol-1&#13;:tab[mult,k]→newtab[nr,k]&#13;:EndFor&#13;:0→newtab[nr,pcol]&#13;:tab[mult,pcol]→newtab[nr,nc]&#13;:newtab→tab&#13;:Disp "Tableau with cut:"&#13;:Disp tab&#13;:Disp " "&#13;:Disp "DUAL SIMPLEX"&#13;:0→iter&#13;:false→done&#13;:While not done and iter&lt;10&#13;:iter+1→iter&#13;:rowDim(tab)→mult&#13;:colDim(tab)→pcol&#13;:0→prow&#13;:0→val&#13;:For i,1,mult-1&#13;:If tab[i,pcol]&lt;-0.0001 Then&#13;:If tab[i,pcol]&lt;val Then&#13;:tab[i,pcol]→val&#13;:i→prow&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If prow=0 Then&#13;:Disp "Dual optimal"&#13;:Disp " "&#13;:true→done&#13;:Else&#13;:Disp "=== DUAL ITERATION ",iter," ==="&#13;:Disp "Leaving var: row ",prow&#13;:9999→minrat&#13;:0→j&#13;:rowDim(tab)→nr&#13;:For k,1,pcol-1&#13;:If tab[prow,k]&lt;-0.0001 Then&#13;:tab[nr,k]/tab[prow,k]→val&#13;:-1*val→val&#13;:If val&lt;minrat Then&#13;:val→minrat&#13;:k→j&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If j=0 Then&#13;:Disp "No dual solution"&#13;:Return&#13;:Else&#13;:Disp "Entering var: x"&amp;string(j)&#13;:Disp "Pivot element:",tab[prow,j]&#13;:Disp " "&#13;:tab[prow,j]→val&#13;:For k,1,pcol&#13;:tab[prow,k]/val→tab[prow,k]&#13;:EndFor&#13;:For i,1,mult&#13;:If i≠prow Then&#13;:tab[i,j]→val&#13;:For k,1,pcol&#13;:tab[i,k]-val*tab[prow,k]→tab[i,k]&#13;:EndFor&#13;:EndIf&#13;:EndFor&#13;:Disp "Tableau after pivot:"&#13;:Disp tab&#13;:Disp " "&#13;:EndIf&#13;:EndIf&#13;:EndWhile&#13;:ncuts+1→ncuts&#13;:EndIf&#13;:EndWhile&#13;:Disp " "&#13;:Disp "Total cuts:",ncuts&#13;:EndPrgm</v></e><e t="7" f="65536" c="0"><n>help</n><p></p><v>Prgm&#13;:Disp "gomory library v2.2.0"&#13;:Disp " "&#13;:Disp "gomory(mat,opt,intvars,ctypes)"&#13;:Disp "  mat: [[A|b][c|0]]"&#13;:Disp "  opt: 1=max, 0=min"&#13;:Disp "  intvars: [1,1,1]"&#13;:Disp "  ctypes: [1,-1,0]"&#13;:Disp "    1=&lt;=, -1=&gt;=, 0=="&#13;:Disp " "&#13;:Disp "Example &lt;=:"&#13;:Disp "gomory\gomory("&#13;:Disp "  [[2,3,3,8]"&#13;:Disp "   [1,4,2,7]"&#13;:Disp "   [1,1,5,0]],1,"&#13;:Disp "  [1,1,1],[1,1])"&#13;:Disp " "&#13;:Disp "Example with &gt;= and =:"&#13;:Disp "ctypes=[1,-1,0] means"&#13;:Disp "  row1: &lt;="&#13;:Disp "  row2: &gt;="&#13;:Disp "  row3: ="&#13;:EndPrgm</v></e></sym><card clay="0" h1="10000" h2="10000" w1="10000" w2="10000"><flag>0</flag><wdgt xmlns:np="urn:TI.Notepad" type="TI.Notepad" ver="1.0"><np:mFlags>0</np:mFlags><np:value>3</np:value><np:txt>\1keyword gomory\  \1keyword library\  \1keyword -\  \1keyword version\  \1keyword 2.0.0\
     2→\1subhead Gomory\  \1subhead Integer\  \1subhead Programming\  \1subhead with\  \1subhead Two-Phase\  \1subhead Simplex\
     3→\1subhead \
     4→\1keyword How\  \1keyword to\  \1keyword use\  \1keyword this\  \1keyword library\
     5→To use this library, follow these steps:
     6→1. Make sure the library document \1keyword gomory\  is in the \1keyword MyLib\  folder.
     7→2. Press \1keyword [ctrl]\  \1keyword [home]\  and select \1keyword Refresh\  \1keyword Libraries\ .
     8→3. Open the Calculator application.
     9→4. Type the function name, such as \0el {gomory\gomory(mat,opt,intvars,ctypes)}. To type the "\\" character on the handheld, press [CAPS] [÷].
    10→
    11→\1keyword Example\  \1keyword 1:\  \1keyword Only\  \1keyword ≤\  \1keyword constraints\
    12→Solve: max Z = x1 + x2 + 5x3
    13→Subject to:
    14→  2x1 + 3x2 + 3x3 ≤ 8
    15→  x1 + 4x2 + 2x3 ≤ 7
    16→  x1, x2, x3 ≥ 0, integer
    17→
    18→\0el {gomory\gomory([[2,3,3,8][1,4,2,7][1,1,5,0]],1,[1,1,1],[1,1])}
    19→
    20→\1keyword Example\  \1keyword 2:\  \1keyword Equality\  \1keyword constraints\  \1keyword (5\  \1keyword variables)\
    21→Solve: max Z = 12x1 + 7x2 + 0x3 + 0x4 + 0x5
    22→Subject to:
    23→  x1 + 2x2 + x3 = 10
    24→  -x1 - 2x2 + x4 = -2
    25→  2x1 + x2 + x5 = 10
    26→  x3, x4, x5 integer; x1, x2 any
Note: Library normalizes negative RHS automatically.
    28→\0el {gomory\gomory([[1,2,1,0,0,10][-1,-2,0,1,0,-2][2,1,0,0,1,10][12,7,0,0,0,0]],1,[0,0,1,1,1],[0,0,0])}
    29→
    30→\1keyword Parameters:\
    31→- mat: combined matrix ((m+1)×(n+1))
    32→  Rows 1..m: [A|b] constraint matrix with RHS
    33→  Row m+1: [c^T|0] objective coefficients
    34→- opt: 1=max, 0=min
    35→- intvars: integer flags [1,1,1] means all integer
    36→- ctypes: constraint types [1,-1,0]
    37→  1 = ≤ (adds slack variable)
    38→  -1 = ≥ (adds surplus + artificial)
    39→  0 = = (adds artificial variable)
    40→
    41→\1keyword Output:\
    42→Step-by-step solution showing:
    43→- Phase 1 (if needed): minimize artificial vars
    44→- Phase 2: solve original objective
    45→- Gomory cuts with formulas
    46→- Dual simplex iterations
    47→- Final integer solution
    48→</np:txt></wdgt></card></prob>
