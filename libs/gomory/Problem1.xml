<?xml version="1.0" encoding="UTF-8" ?><prob xmlns="urn:TI.Problem" ver="1.0"><sym><e t="6" f="65536" c="0"><n>version</n><p></p><v>Func&#13;:Return "1.0.0"&#13;:EndFunc</v></e><e t="7" f="65536" c="0"><n>gomory</n><p>mat,opt,intvars</p><v>Prgm&#13;:Local m,n,a,b,c,i,j,tab,mult,pcol,prow,minval,minrat,done,iter&#13;:Disp "=== GOMORY v2.2.1 ==="&#13;:rowDim(mat)→m&#13;:colDim(mat)→n&#13;:m-1→m&#13;:n-1→n&#13;:subMat(mat,1,1,m,n)→a&#13;:subMat(mat,1,n+1,m,n+1)→b&#13;:subMat(mat,m+1,1,m+1,n)→c&#13;:If opt=0 Then&#13;:-1→mult&#13;:Else&#13;:1→mult&#13;:EndIf&#13;:newMat(m+1,n+m+1)→tab&#13;:For i,1,m&#13;:For j,1,n&#13;:a[i,j]→tab[i,j]&#13;:EndFor&#13;:EndFor&#13;:For i,1,m&#13;:1→tab[i,n+i]&#13;:b[i,1]→tab[i,n+m+1]&#13;:EndFor&#13;:For j,1,n&#13;:-1*mult*c[1,j]→tab[m+1,j]&#13;:EndFor&#13;:Disp "Simplex method"&#13;:0→iter&#13;:false→done&#13;:While not done and iter&lt;20&#13;:iter+1→iter&#13;:Disp "Iteration:",iter&#13;:rowDim(tab)→m&#13;:colDim(tab)→n&#13;:0→pcol&#13;:0→minval&#13;:For j,1,n-1&#13;:If tab[m,j]&lt;minval Then&#13;:tab[m,j]→minval&#13;:j→pcol&#13;:EndIf&#13;:EndFor&#13;:If pcol=0 Then&#13;:Disp "OPTIMAL SOLUTION"&#13;:Disp "Z=",tab[m,n]&#13;:true→done&#13;:Else&#13;:9999→minrat&#13;:0→prow&#13;:For i,1,m-1&#13;:If tab[i,pcol]&gt;0.000001 Then&#13;:tab[i,n]/tab[i,pcol]→mult&#13;:If mult&lt;minrat Then&#13;:mult→minrat&#13;:i→prow&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If prow=0 Then&#13;:Disp "UNBOUNDED"&#13;:Return&#13;:Else&#13;:tab[prow,pcol]→mult&#13;:For j,1,n&#13;:tab[prow,j]/mult→tab[prow,j]&#13;:EndFor&#13;:For i,1,m&#13;:If i≠prow Then&#13;:tab[i,pcol]→mult&#13;:For j,1,n&#13;:tab[i,j]-mult*tab[prow,j]→tab[i,j]&#13;:EndFor&#13;:EndIf&#13;:EndFor&#13;:EndIf&#13;:EndIf&#13;:EndWhile&#13;:Disp "LP relaxation done"&#13;:Disp tab&#13;:Local ncuts,intdone&#13;:0→ncuts&#13;:false→intdone&#13;:While not intdone and ncuts&lt;10&#13;:Disp " "&#13;:Disp "=== CUT ",ncuts+1," ==="&#13;:Disp "Checking integrality"&#13;:rowDim(mat)→m&#13;:colDim(mat)→n&#13;:m-1→m&#13;:n-1→n&#13;:rowDim(tab)→mult&#13;:colDim(tab)→pcol&#13;:Local isint,val,frac,cnt,row&#13;:true→isint&#13;:For j,1,n&#13;:0→val&#13;:0→cnt&#13;:0→row&#13;:For i,1,mult-1&#13;:If abs(tab[i,j])&gt;0.0001 Then&#13;:cnt+1→cnt&#13;:If abs(tab[i,j]-1)&lt;0.0001 Then&#13;:i→row&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If cnt=1 and row&gt;0 Then&#13;:tab[row,pcol]→val&#13;:EndIf&#13;:Disp "x"&amp;string(j)&amp;"=",val&#13;:val-floor(val)→frac&#13;:If frac&gt;0.0001 and frac&lt;0.9999 Then&#13;:false→isint&#13;:Disp "  not integer"&#13;:EndIf&#13;:EndFor&#13;:Disp " "&#13;:If isint Then&#13;:Disp "OPTIMAL INTEGER SOLUTION"&#13;:Disp "Z=",tab[mult,pcol]&#13;:true→intdone&#13;:Else&#13;:Disp "Solution not integer"&#13;:Disp "Generating Gomory cut"&#13;:Local maxfrac,cutrow&#13;:0→maxfrac&#13;:0→cutrow&#13;:For i,1,mult-1&#13;:tab[i,pcol]→val&#13;:val-floor(val)→frac&#13;:If frac&gt;maxfrac Then&#13;:frac→maxfrac&#13;:i→cutrow&#13;:EndIf&#13;:EndFor&#13;:Disp "Cut from row:",cutrow&#13;:Disp "Max frac:",maxfrac&#13;:Disp " "&#13;:Disp "Building cut constraint"&#13;:Local cutrow_data,k&#13;:newList(pcol)→cutrow_data&#13;:For k,1,pcol-1&#13;:tab[cutrow,k]→val&#13;:val-floor(val)→frac&#13;:-1*frac→cutrow_data[k]&#13;:EndFor&#13;:tab[cutrow,pcol]→val&#13;:val-floor(val)→frac&#13;:-1*frac→cutrow_data[pcol]&#13;:Disp "Cut coefficients:"&#13;:Disp cutrow_data&#13;:Disp " "&#13;:Disp "Adding cut to tableau"&#13;:Local newtab,nr,nc&#13;:mult+1→nr&#13;:pcol+1→nc&#13;:newMat(nr,nc)→newtab&#13;:For i,1,mult-1&#13;:For k,1,pcol-1&#13;:tab[i,k]→newtab[i,k]&#13;:EndFor&#13;:0→newtab[i,pcol]&#13;:tab[i,pcol]→newtab[i,nc]&#13;:EndFor&#13;:For k,1,pcol-1&#13;:cutrow_data[k]→newtab[mult,k]&#13;:EndFor&#13;:1→newtab[mult,pcol]&#13;:cutrow_data[pcol]→newtab[mult,nc]&#13;:For k,1,pcol-1&#13;:tab[mult,k]→newtab[nr,k]&#13;:EndFor&#13;:0→newtab[nr,pcol]&#13;:tab[mult,pcol]→newtab[nr,nc]&#13;:newtab→tab&#13;:Disp "Cut added"&#13;:Disp tab&#13;:Disp " "&#13;:Disp "Dual simplex"&#13;:0→iter&#13;:false→done&#13;:While not done and iter&lt;10&#13;:iter+1→iter&#13;:Disp "Dual iter:",iter&#13;:rowDim(tab)→mult&#13;:colDim(tab)→pcol&#13;:0→prow&#13;:0→val&#13;:For i,1,mult-1&#13;:If tab[i,pcol]&lt;-0.0001 Then&#13;:If tab[i,pcol]&lt;val Then&#13;:tab[i,pcol]→val&#13;:i→prow&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If prow=0 Then&#13;:Disp "Dual optimal"&#13;:true→done&#13;:Else&#13;:9999→minrat&#13;:0→j&#13;:rowDim(tab)→nr&#13;:For k,1,pcol-1&#13;:If tab[prow,k]&lt;-0.0001 Then&#13;:tab[nr,k]/tab[prow,k]→val&#13;:-1*val→val&#13;:If val&lt;minrat Then&#13;:val→minrat&#13;:k→j&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If j=0 Then&#13;:Disp "No dual solution"&#13;:Return&#13;:Else&#13;:tab[prow,j]→val&#13;:For k,1,pcol&#13;:tab[prow,k]/val→tab[prow,k]&#13;:EndFor&#13;:For i,1,mult&#13;:If i≠prow Then&#13;:tab[i,j]→val&#13;:For k,1,pcol&#13;:tab[i,k]-val*tab[prow,k]→tab[i,k]&#13;:EndFor&#13;:EndIf&#13;:EndFor&#13;:EndIf&#13;:EndIf&#13;:EndWhile&#13;:Disp "Dual done"&#13;:Disp tab&#13;:ncuts+1→ncuts&#13;:EndIf&#13;:EndWhile&#13;:Disp " "&#13;:Disp "Total cuts:",ncuts&#13;:EndPrgm</v></e><e t="7" f="65536" c="0"><n>help</n><p></p><v>Prgm&#13;:Disp "gomory library v1.0.0"&#13;:Disp " "&#13;:Disp "gomory(mat,opt,intvars)"&#13;:Disp "  mat: [[A|b][c|0]]"&#13;:Disp "  opt: 1=max, 0=min"&#13;:Disp "  intvars: [1,1,1]"&#13;:Disp " "&#13;:Disp "Example:"&#13;:Disp "gomory\gomory("&#13;:Disp "  [[2,3,3,8]"&#13;:Disp "   [1,4,2,7]"&#13;:Disp "   [1,1,5,0]],1,"&#13;:Disp "  [1,1,1])"&#13;:EndPrgm</v></e></sym><card clay="0" h1="10000" h2="10000" w1="10000" w2="10000"><flag>0</flag><wdgt xmlns:np="urn:TI.Notepad" type="TI.Notepad" ver="1.0"><np:mFlags>0</np:mFlags><np:value>3</np:value><np:txt>\1keyword gomory\  \1keyword library\  \1keyword -\  \1keyword version\  \1keyword 1.0.0\
     2→\1subhead Gomory\  \1subhead Integer\  \1subhead Programming\
     3→\1subhead \
     4→\1keyword How\  \1keyword to\  \1keyword use\  \1keyword this\  \1keyword library\
     5→To use this library, follow these steps:
     6→1. Make sure the library document \1keyword gomory\  is in the \1keyword MyLib\  folder.
     7→2. Press \1keyword [ctrl]\  \1keyword [home]\  and select \1keyword Refresh\  \1keyword Libraries\ .
     8→3. Open the Calculator application.
     9→4. Type the function name, such as \0el {gomory\gomory(mat,opt,intvars)}. To type the "\\" character on the handheld, press [CAPS] [÷].
    10→
    11→\1keyword Example:\
    12→Solve: max Z = x1 + x2 + 5x3
    13→Subject to:
    14→  2x1 + 3x2 + 3x3 ≤ 8
    15→  x1 + 4x2 + 2x3 ≤ 7
    16→  x1, x2, x3 ≥ 0, integer
    17→
    18→\0el {gomory\gomory([[2,3,3,8][1,4,2,7][1,1,5,0]],1,[1,1,1])}
    19→
    20→\1keyword Parameters:\
    21→- mat: combined matrix ((m+1)×(n+1))
    22→  Rows 1..m: [A|b] constraint matrix with RHS
    23→  Row m+1: [c^T|0] objective coefficients
    24→- opt: 1=max, 0=min
    25→- intvars: integer flags [1,1,1] means all integer
    26→
    27→\1keyword Output:\
    28→Step-by-step solution showing:
    29→- Canonical form
    30→- Simplex iterations
    31→- Gomory cuts
    32→- Dual simplex iterations
    33→- Final integer solution
    34→</np:txt></wdgt></card></prob>
