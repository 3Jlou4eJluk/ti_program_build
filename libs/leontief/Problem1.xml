<?xml version="1.0" encoding="UTF-8" ?><prob xmlns="urn:TI.Problem" ver="1.0"><sym><e t="6" f="65536"><n>version</n><p></p><v>Func&#13;:©version(): returns library version&#13;:Return "1.0.0"&#13;:EndFunc</v></e><e t="6" f="65536"><n>is_productive</n><p>a</p><v>Func&#13;:©is_productive(matrix): check if matrix is productive (column sum test)&#13;:Local n,r,i,j,s&#13;:colDim(a)→n&#13;:rowDim(a)→r&#13;:For j,1,n&#13;:0→s&#13;:For i,1,r&#13;:s+a[i,j]→s&#13;:EndFor&#13;:If s&gt;=1 Then&#13;:Return 0&#13;:EndIf&#13;:EndFor&#13;:Return 1&#13;:EndFunc</v></e><e t="6" f="65536"><n>calc_prod</n><p>a,y</p><v>Func&#13;:©calc_prod(matrix,demand): computes required output X = (E-A)^(-1)·Y&#13;:Local n,e,ea,inv&#13;:colDim(a)→n&#13;:identity(n)→e&#13;:e-a→ea&#13;:ea^(-1)→inv&#13;:Return inv*y&#13;:EndFunc</v></e><e t="7" f="65536"><n>check_prod</n><p>a</p><v>Prgm&#13;:©check_prod(matrix): step-by-step productivity analysis&#13;:Local n,r,i,j,s,e,ea,inv,prod&#13;:Disp "=== LEONTIEF PRODUCTIVITY ==="&#13;:Disp " "&#13;:Disp "Input matrix A:"&#13;:Disp a&#13;:colDim(a)→n&#13;:rowDim(a)→r&#13;:Disp " "&#13;:Disp "Step 1: Column sums"&#13;:1→prod&#13;:For j,1,n&#13;:0→s&#13;:For i,1,r&#13;:s+a[i,j]→s&#13;:EndFor&#13;:Disp "Col "&amp;string(j)&amp;": "&amp;string(s)&#13;:If s&lt;1 Then&#13;:Disp "  Sum &lt; 1 (ok)"&#13;:Else&#13;:Disp "  Sum &gt;= 1 (FAIL)"&#13;:0→prod&#13;:EndIf&#13;:EndFor&#13;:Disp " "&#13;:If prod=1 Then&#13;:Disp "All column sums &lt; 1"&#13;:Disp " "&#13;:Disp "Step 2: Compute (E-A)"&#13;:identity(n)→e&#13;:e-a→ea&#13;:Disp ea&#13;:Disp " "&#13;:Disp "Step 3: Compute (E-A)^(-1)"&#13;:ea^(-1)→inv&#13;:Disp inv&#13;:Disp " "&#13;:Disp "RESULT: PRODUCTIVE"&#13;:Else&#13;:Disp "Column sum check FAILED"&#13;:Disp " "&#13;:Disp "RESULT: NOT PRODUCTIVE"&#13;:EndIf&#13;:EndPrgm</v></e><e t="7" f="65536"><n>show_prod</n><p>a,y</p><v>Prgm&#13;:©show_prod(matrix,demand): calculates required output X = (E-A)^(-1)·Y&#13;:Local n,e,ea,inv,x,i&#13;:Disp "=== REQUIRED OUTPUT CALCULATOR ==="&#13;:Disp " "&#13;:Disp "Input matrix A:"&#13;:Disp a&#13;:Disp " "&#13;:Disp "Final demand vector Y:"&#13;:Disp y&#13;:colDim(a)→n&#13;:Disp " "&#13;:Disp "Step 1: Compute (E-A)"&#13;:identity(n)→e&#13;:e-a→ea&#13;:Disp ea&#13;:Disp " "&#13;:Disp "Step 2: Compute (E-A)^(-1)"&#13;:ea^(-1)→inv&#13;:Disp inv&#13;:Disp " "&#13;:Disp "Step 3: Compute X = (E-A)^(-1)·Y"&#13;:inv*y→x&#13;:Disp x&#13;:Disp " "&#13;:Disp "Required production by sector:"&#13;:For i,1,n&#13;:Disp "Sector "&amp;string(i)&amp;": X"&amp;string(i)&amp;" = "&amp;string(x[i,1])&#13;:EndFor&#13;:EndPrgm</v></e><e t="7" f="65536"><n>solve_output</n><p>a,dy</p><v>Prgm&#13;:©solve_output(matrix,delta_y): solves ΔX = (E-A)^(-1)·ΔY&#13;:Local n,e,ea,inv,dx,i&#13;:Disp "=== OUTPUT CHANGE SOLVER ==="&#13;:Disp " "&#13;:Disp "Input matrix A:"&#13;:Disp a&#13;:Disp " "&#13;:Disp "Final demand change ΔY:"&#13;:Disp dy&#13;:colDim(a)→n&#13;:Disp " "&#13;:Disp "Step 1: Compute (E-A)"&#13;:identity(n)→e&#13;:e-a→ea&#13;:Disp ea&#13;:Disp " "&#13;:Disp "Step 2: Compute (E-A)^(-1)"&#13;:ea^(-1)→inv&#13;:Disp inv&#13;:Disp " "&#13;:Disp "Step 3: Compute ΔX = (E-A)^(-1)·ΔY"&#13;:inv*dy→dx&#13;:Disp dx&#13;:Disp " "&#13;:Disp "Output changes by sector:"&#13;:For i,1,n&#13;:Disp "Sector "&amp;string(i)&amp;": ΔX"&amp;string(i)&amp;" = "&amp;string(dx[i,1])&#13;:EndFor&#13;:EndPrgm</v></e><e t="7" f="65536"><n>calc_output</n><p>xij,y,ystar</p><v>Prgm&#13;:©calc_output(xij,y,ystar): computes required output X* = (E-A)^(-1)·Y*&#13;:Local n,i,j,a,e,ea,inv,xstar,xgross,s&#13;:Disp "=== REQUIRED OUTPUT SOLVER ==="&#13;:Disp " "&#13;:Disp "Input flow matrix {x_ij}:"&#13;:Disp xij&#13;:Disp " "&#13;:Disp "Current final demand Y:"&#13;:Disp y&#13;:Disp " "&#13;:Disp "Required final demand Y*:"&#13;:Disp ystar&#13;:colDim(xij)→n&#13;:Disp " "&#13;:Disp "Step 1: Compute gross output X"&#13;:Disp "X_j = (sum_i x_ij) + Y_j"&#13;:newMat(n,1)→xgross&#13;:For i,1,n&#13;:0→s&#13;:For j,1,n&#13;:s+xij[i,j]→s&#13;:EndFor&#13;:s+y[i,1]→xgross[i,1]&#13;:EndFor&#13;:Disp xgross&#13;:Disp " "&#13;:Disp "Step 2: Compute matrix A"&#13;:Disp "a_ij = x_ij / X_j"&#13;:newMat(n,n)→a&#13;:For i,1,n&#13;:For j,1,n&#13;:xij[i,j]/xgross[j,1]→a[i,j]&#13;:EndFor&#13;:EndFor&#13;:Disp a&#13;:Disp " "&#13;:Disp "Step 3: Compute (E-A)"&#13;:identity(n)→e&#13;:e-a→ea&#13;:Disp ea&#13;:Disp " "&#13;:Disp "Step 4: Compute (E-A)^(-1)"&#13;:ea^(-1)→inv&#13;:Disp inv&#13;:Disp " "&#13;:Disp "Step 5: Compute X* = (E-A)^(-1)·Y*"&#13;:inv*ystar→xstar&#13;:Disp xstar&#13;:Disp " "&#13;:Disp "Required production by sector:"&#13;:For i,1,n&#13;:Disp "Sector "&amp;string(i)&amp;": X*"&amp;string(i)&amp;" = "&amp;string(xstar[i,1])&#13;:EndFor&#13;:EndPrgm</v></e></sym><card clay="0" h1="10000" h2="10000" w1="10000" w2="10000"><flag>0</flag><wdgt xmlns:np="urn:TI.Notepad" type="TI.Notepad" ver="1.0"><np:mFlags>0</np:mFlags><np:value>3</np:value><np:txt>\1keyword leontief\  \1keyword library\  \1keyword -\  \1keyword version\  \1keyword 1.0.0\
\1subhead Leontief\  \1subhead Input-Output\  \1subhead Model\
\1subhead \
\1keyword How\  \1keyword to\  \1keyword use\  \1keyword this\  \1keyword library\
To use a function or program from this library, follow these steps:
1. Make sure the library document \1keyword leontief\  is in the \1keyword MyLib\  folder.
2. Press \1keyword [ctrl]\  \1keyword [home]\  and select \1keyword Refresh\  \1keyword Libraries\ .
3. Open the Calculator application.
4. Open the Catalog and use the library tab to find and insert the object.
    - or -
    Type the name of the object, such as \0el {leontief\is_productive()}. To type the "\\" character on the handheld, press [CAPS] [÷].
5. If arguments are required, type them inside the parentheses.
    For example, \0el {leontief\is_productive([[0.04,0.02,0.06],[0.10,0.14,0.06],[0.06,0.04,0.08]])}
</np:txt></wdgt></card><card clay="0" h1="10000" h2="10000" w1="10000" w2="10000"><flag>0</flag><wdgt xmlns:np="urn:TI.Notepad" type="TI.Notepad" ver="1.0"><np:mFlags>0</np:mFlags><np:value>3</np:value><np:txt>\1keyword leontief\  \1keyword library\  \1keyword -\  \1keyword version\  \1keyword 1.0.0\
======================
\1keyword TABLE\  \1keyword OF\  \1keyword CONTENTS\
\1keyword \
\1title Public\  \1title functions\  \1title and\  \1title programs\
\1title \
\0el {version()} - returns library version
    Returns: \0el {"1.0.0"}
    Example: \0el {leontief\version()}

\0el {is_productive(matrix_a)} - productivity check (sufficient condition)
    Tests if all column sums &lt; 1 (sufficient condition for productivity)
    Parameters:
      \1keyword matrix_a\  - direct requirements matrix (Leontief matrix)
    Returns: \0el {1} if productive, \0el {0} otherwise
    Example: \0el {leontief\is_productive([[0.04,0.02,0.06],[0.10,0.14,0.06],[0.06,0.04,0.08]])}
    Result: \0el {1} (productive)

\0el {calc_prod(matrix_a, demand_y)} - required production calculator
    Computes required output vector X from matrix A and final demand vector Y.
    Uses the formula: \1keyword X\  \1keyword =\  \1keyword (E\  \1keyword -\  \1keyword A)^(-1)\  \1keyword ·\  \1keyword Y\
    Parameters:
      \1keyword matrix_a\  - direct requirements matrix (Leontief matrix)
      \1keyword demand_y\  - column vector of final demand
    Returns: column vector X (required gross output)
    Example: \0el {leontief\calc_prod([[0.04,0.02,0.06],[0.10,0.14,0.06],[0.06,0.04,0.08]],[[88][164][129]])}
    Result: X = [100, 200, 150]

\0el {check_prod(matrix_a)} - step-by-step productivity analysis
    Performs detailed productivity check with step-by-step output:
      1. Displays input matrix A
      2. Checks column sums (sufficient condition)
      3. Computes (E-A) matrix
      4. Computes (E-A)^(-1) inverse matrix
      5. Shows final result: PRODUCTIVE or NOT PRODUCTIVE
    Parameters:
      \1keyword matrix_a\  - direct requirements matrix (Leontief matrix)
    Example: \0el {leontief\check_prod([[0.04,0.02,0.06],[0.10,0.14,0.06],[0.06,0.04,0.08]])}

\0el {show_prod(matrix_a, demand_y)} - required production calculator (step-by-step)
    Calculates required output vector X with step-by-step display.
    Uses the formula: \1keyword X\  \1keyword =\  \1keyword (E\  \1keyword -\  \1keyword A)^(-1)\  \1keyword ·\  \1keyword Y\
    Displays step-by-step:
      1. Input matrix A and demand vector Y
      2. Computes (E-A)
      3. Computes (E-A)^(-1)
      4. Computes X = (E-A)^(-1)·Y
      5. Shows required production for each sector
    Parameters:
      \1keyword matrix_a\  - direct requirements matrix (Leontief matrix)
      \1keyword demand_y\  - column vector of final demand
    Example: \0el {leontief\show_prod([[0.04,0.02,0.06],[0.10,0.14,0.06],[0.06,0.04,0.08]],[[88][164][129]])}
    Problem: Given matrix A and demand Y=[88,164,129], find required output X.
    Result: X = [100, 200, 150]

\0el {solve_output(matrix_a, delta_y)} - output change solver
    Solves for change in gross output ΔX when final demand changes by ΔY.
    Uses the formula: \1keyword ΔX\  \1keyword =\  \1keyword (E\  \1keyword -\  \1keyword A)^(-1)\  \1keyword ·\  \1keyword ΔY\
    Displays step-by-step:
      1. Input matrix A and demand change ΔY
      2. Computes (E-A)
      3. Computes (E-A)^(-1)
      4. Computes ΔX = (E-A)^(-1)·ΔY
      5. Shows output changes for each sector
    Parameters:
      \1keyword matrix_a\  - direct requirements matrix (Leontief matrix)
      \1keyword delta_y\  - column vector of final demand changes
    Example: \0el {leontief\solve_output([[0.04,0.02,0.06],[0.10,0.14,0.06],[0.06,0.04,0.08]],[[0][2][0]])}
    Problem: Find change in sector 3 output when sector 2 final demand increases by 2.
    Result: ΔX₃ = 0.1182

\0el {calc_output(xij, y, ystar)} - required production calculator
    Computes required gross output X* from flow matrix, current demand, and required demand.
    Uses the algorithm:
      1. Compute gross output: X_j = (sum_i x_ij) + Y_j
      2. Compute matrix A: a_ij = x_ij / X_j
      3. Compute (E-A)
      4. Compute (E-A)^(-1)
      5. Compute X* = (E-A)^(-1)·Y*
    Parameters:
      \1keyword xij\  - intersectoral flow matrix (n×n)
      \1keyword y\  - current final demand vector Y (n×1)
      \1keyword ystar\  - required final demand vector Y* (n×1)
    Example: \0el {leontief\calc_output([[10,30,10][30,50,20][10,20,20]],[[150][0][50]],[[60][120][60]])}
    Problem: Given flow matrix and current demand Y=[150,0,50], find required output for Y*=[60,120,60].
    Result: X* = [120, 280, 160]

\1title Theoretical\  \1title background\
A matrix A is \1keyword productive\  if there exists a non-zero output vector X &gt; 0.
\1keyword Leontief\  \1keyword Theorem\ : Matrix A is productive ⟺ (E-A) has a non-negative inverse.
\1keyword Sufficient\  \1keyword condition\ : If sum of elements in each column of A is strictly less than 1, then A is productive.
</np:txt></wdgt></card></prob>
