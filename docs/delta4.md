# delta4.md - Проблема локальных переменных в циклах

Проблемы, выявленные при разработке gomory v2.1.0 (улучшенный вывод).

## Дата
2025-10-19

## Проблема: LP relaxation display (Step 10)

### Контекст

При добавлении вывода решения LP-релаксации (P1 #6) возникла ситуация:
- Код скомпилировался успешно (Luna без ошибок)
- Библиотека создалась (4.2K)
- Но функция **не работала** на калькуляторе

### Код, который НЕ работал (Step 10 - полная реализация):

```
:Disp "---"&#13;:Disp "LP RELAXATION SOLUTION"&#13;:Disp "---"&#13;:rowDim(mat)→m&#13;:colDim(mat)→n&#13;:m-1→m&#13;:n-1→n&#13;:rowDim(tab)→mult&#13;:colDim(tab)→pcol&#13;:For j,1,n&#13;:0→val&#13;:0→cnt&#13;:0→row&#13;:For i,1,mult-1&#13;:If abs(tab[i,j])&gt;0.0001 Then&#13;:cnt+1→cnt&#13;:If abs(tab[i,j]-1)&lt;0.0001 Then&#13;:i→row&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If cnt=1 and row&gt;0 Then&#13;:tab[row,pcol]→val&#13;:EndIf&#13;:val-floor(val)→frac&#13;:If intvars[1,j]=1 and frac&gt;0.0001 and frac&lt;0.9999 Then&#13;:Disp "x"&amp;string(j)&amp;"=",val," &lt;- fractional"&#13;:Else&#13;:Disp "x"&amp;string(j)&amp;"=",val&#13;:EndIf&#13;:EndFor&#13;:Disp "Z =",tab[mult,pcol]
```

**Симптомы:**
- Build: ✅ успешно (4.2K)
- Работа на калькуляторе: ❌ "Опа, не работает теперь"

**Предполагаемая причина:**
Переменная `frac` используется в цикле, но:
1. Она объявлена в начале функции: `:Local m,n,a,b,c,i,j,k,tab,mult,pcol,prow,minval,minrat,done,iter,cnt,row,val`
2. НО `frac` не была включена в это объявление!
3. Позже в коде `frac` объявляется в другом месте: `:Local isint,val,frac,cnt,row` (в секции integrality check)

**Проблема:** Использование переменной `frac` в новом месте без явного объявления или с конфликтом области видимости.

## Решение: Инкрементальная разработка

### Методология

Вместо добавления всего кода сразу, использовали поэтапный подход:

#### Step 10a - Только заголовок и Z

```
:Disp "---"&#13;:Disp "LP RELAXATION SOLUTION"&#13;:Disp "---"&#13;:rowDim(tab)→mult&#13;:colDim(tab)→pcol&#13;:Disp "Z =",tab[mult,pcol]&#13;:Disp " "
```

**Результат:** ✅ Работает (4.1K)

#### Step 10b - Добавление цикла переменных

```
:Disp "Z =",tab[mult,pcol]&#13;:rowDim(mat)→m&#13;:colDim(mat)→n&#13;:m-1→m&#13;:n-1→n&#13;:For j,1,n&#13;:0→val&#13;:0→cnt&#13;:0→row&#13;:For i,1,mult-1&#13;:If abs(tab[i,j])&gt;0.0001 Then&#13;:cnt+1→cnt&#13;:If abs(tab[i,j]-1)&lt;0.0001 Then&#13;:i→row&#13;:EndIf&#13;:EndIf&#13;:EndFor&#13;:If cnt=1 and row&gt;0 Then&#13;:tab[row,pcol]→val&#13;:EndIf&#13;:Disp "x"&amp;string(j)&amp;"=",val&#13;:EndFor
```

**Результат:** ✅ Работает (4.2K)

#### Step 10c - Добавление маркировки дробных переменных

**КЛЮЧЕВОЕ ИЗМЕНЕНИЕ:** Явное объявление `frac` как локальной переменной **внутри цикла**:

```
:If cnt=1 and row&gt;0 Then&#13;:tab[row,pcol]→val&#13;:EndIf&#13;:Local frac&#13;:val-floor(val)→frac&#13;:If intvars[1,j]=1 and frac&gt;0.0001 and frac&lt;0.9999 Then&#13;:Disp "x"&amp;string(j)&amp;"=",val," &lt;- fractional"&#13;:Else&#13;:Disp "x"&amp;string(j)&amp;"=",val&#13;:EndIf&#13;:EndFor
```

**Результат:** ✅ Работает (4.2K)

## Корневая причина

### Проблема области видимости переменных

В TI-BASIC переменные, объявленные через `Local`, имеют **область видимости функции**, но:

1. **Проблема повторного использования:** Если переменная с тем же именем объявляется в разных местах функции (например, `frac` в integrality check section), это может вызвать конфликт.

2. **Решение:** Явно объявить `Local frac` непосредственно **перед использованием** в новом контексте.

### Почему инкрементальный подход помог

При добавлении кода по частям мы:
1. Точно определили, что именно вызывает проблему
2. Поняли, что дело в переменной `frac`
3. Добавили явное объявление `Local frac` перед использованием

## Правила для TI-BASIC

### ✅ Правильно

```
:For j,1,n
:  0→val
:  0→cnt
:  ... получаем val ...
:  Local frac            ← явное объявление перед использованием
:  val-floor(val)→frac
:  If frac>0.01 Then
:    Disp "fractional"
:  EndIf
:EndFor
```

### ❌ Неправильно

```
:Local frac              ← объявлено в начале функции
:...
:... 100 строк кода ...
:...
:Local cnt,row,frac      ← ПОВТОРНОЕ объявление в другой секции
:...
:... ещё 50 строк ...
:...
:For j,1,n
:  val-floor(val)→frac  ← использование без явного Local здесь
:EndFor
```

## Методология отладки при "функция не появляется"

### Когда код компилируется, но не работает

1. **Откатиться** к последней рабочей версии
2. **Добавлять код маленькими блоками** (5-20 строк)
3. **Тестировать после каждого добавления**
4. **Точно определить**, какой блок вызывает проблему
5. **Анализировать** именно этот блок:
   - Переменные
   - Область видимости
   - Синтаксис (Then, →, &)
   - XML-экранирование (&lt;, &gt;)

### Пример из практики (gomory v2.1.0)

```
Step 9  (4.1K) ✅ Работает - Canonical form
Step 10 (4.2K) ❌ НЕ РАБОТАЕТ - LP relaxation (всё сразу)
                  ↓ откат
Step 9  (4.1K) ✅ Работает снова
                  ↓ инкрементально
Step 10a (4.1K) ✅ Работает - только header + Z
Step 10b (4.2K) ✅ Работает - добавлен цикл переменных
Step 10c (4.2K) ✅ РАБОТАЕТ - добавлена маркировка дробных с Local frac
```

## Новые правила для delta.md

### Правило #7: Локальные переменные в циклах

**Проблема:**
Переменная, объявленная в начале функции или в другой секции, может конфликтовать при использовании в новом контексте.

**Решение:**
Явно объявляйте `Local variable_name` непосредственно перед использованием в цикле, даже если переменная уже объявлена где-то в функции.

**Пример:**
```
:For j,1,n
:  Local temp_var       ← явное объявление
:  calculation→temp_var
:  If temp_var>0 Then
:    ...
:  EndIf
:EndFor
```

### Правило #8: Инкрементальная разработка - всегда

При добавлении нового функционала:

1. ✅ Добавить минимальный блок (header)
2. ✅ Протестировать
3. ✅ Добавить следующий блок (loop structure)
4. ✅ Протестировать
5. ✅ Добавить логику (conditionals)
6. ✅ Протестировать
7. ✅ Добавить вывод
8. ✅ Протестировать

❌ НЕ добавлять всё сразу, даже если код выглядит правильным!

## Инструменты отладки

### Disp для проверки переменных

```
:Local frac
:val-floor(val)→frac
:Disp "DEBUG: frac=",frac    ← отладочный вывод
:If frac>0.01 Then
  ...
:EndIf
```

### Проверка объявлений

Перед добавлением нового кода:
1. Проверить все `Local` декларации в функции
2. Найти переменную по имени (Ctrl+F в XML)
3. Убедиться, что нет конфликтов

## Контрольный список

### Перед добавлением нового кода:

- [ ] Определить, какие новые переменные нужны
- [ ] Проверить, не конфликтуют ли имена с существующими
- [ ] Решить, где объявить `Local` (в начале или перед использованием)
- [ ] Добавить минимальный блок
- [ ] Собрать и протестировать
- [ ] Только после успеха - добавлять следующий блок

### При ошибке "функция не работает":

- [ ] Откатиться к последней рабочей версии
- [ ] Разбить изменение на 3-5 маленьких шагов
- [ ] Добавить шаг 1, собрать, тестировать
- [ ] Добавить шаг 2, собрать, тестировать
- [ ] ...
- [ ] Найти точный шаг, который вызывает проблему
- [ ] Анализировать только этот шаг

## Выводы

1. **Инкрементальная разработка** - не опция, а **обязательная методология** для TI-BASIC
2. **Локальные переменные** требуют осторожности - объявляйте `Local` перед каждым новым использованием
3. **Тестирование после каждого изменения** позволяет точно определить проблемный код
4. **Компиляция без ошибок ≠ рабочий код** - всегда тестируйте на калькуляторе
5. **Терпение и методичность** важнее скорости разработки

---

**Версия документа:** 1.0
**Дата:** 2025-10-19
**Библиотека:** gomory v2.1.0
**Проблема:** Solved through incremental development
