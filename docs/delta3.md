# Проблемы разработки библиотек TI-Nspire (TI-BASIC)

Документация всех проблем, ошибок и особенностей, выявленных при разработке библиотеки `gomory`.

## Оглавление

1. [Компиляция и появление функций в библиотеке](#компиляция-и-появление-функций-в-библиотеке)
2. [Особенности синтаксиса TI-BASIC](#особенности-синтаксиса-ti-basic)
3. [Проблемы при разработке Gomory v0.1-v2.2.1](#проблемы-при-разработке-gomory-v01-v221)
4. [Методология отладки](#методология-отладки)
5. [Ограничения и обходные пути](#ограничения-и-обходные-пути)

---

## Компиляция и появление функций в библиотеке

### Проблема: "Variable is not defined"

**Симптомы:**
- Функция скомпилировалась без ошибок Luna
- Библиотека `.tns` создана
- После `Refresh Libraries` функция НЕ появляется в каталоге
- При вызове `library\function()` ошибка **"Variable is not defined"**

**Причина:**
Синтаксические ошибки в коде функции **не выявляются компилятором Luna**, но **блокируют парсинг** на калькуляторе. Функция с ошибкой просто не добавляется в библиотеку.

**Индикатор:**
Если функция не появилась в документе библиотеки (Problem1.xml) после `Refresh Libraries` → есть синтаксическая ошибка.

**Решение:**
1. Инкрементальная разработка — добавлять код по маленьким блокам
2. Тестировать после каждого добавления
3. Если функция пропала — откатить последнее изменение

**Пример из разработки:**
```
v0.1 - работает (пустая функция)
v0.2 - работает (добавлен input parsing)
v0.3 - НЕ РАБОТАЕТ → откат, проверка синтаксиса
```

---

## Особенности синтаксиса TI-BASIC

### 1. Оператор присваивания в программах

**В Func:**
```
:= (допустимо в функциях)
```

**В Prgm:**
```
→ (ТОЛЬКО стрелка, := НЕ работает!)
```

**Ошибка:**
```
:dim(list)→n      ✅ правильно
:dim(list):=n     ❌ синтаксическая ошибка в Prgm
```

### 2. Команда Pause

**Проблема:**
Добавление `Pause` в код вызывает ошибку компиляции/парсинга.

**Обход:**
Использовать пустой `Disp` для остановки:
```
:Disp " "
:Disp "Press ENTER to continue"
```

Калькулятор автоматически останавливается при выводе через `Disp`.

### 3. Формат XML кодирования

**Переносы строк:**
```xml
<v>Prgm&#13;:Local x,y&#13;:0→x&#13;:EndPrgm</v>
```
Каждая строка заканчивается `&#13;` (carriage return).

**Атрибуты элементов:**
```xml
<e t="7" f="65536" c="0">   ✅ обязателен атрибут c="0"
<e t="7" f="65536">         ❌ может вызвать проблемы
```

### 4. Циклы и условия

**For-цикл:**
```
:For i,1,n          ✅ правильно
:For i,1,n,1        ✅ тоже правильно (шаг явно)
```

**While-цикл:**
```
:While not done and iter<20
:  ... тело ...
:EndWhile
```

**If-Then:**
```
:If condition Then
:  ... действия ...
:EndIf

:If condition Then
:  ... действия ...
:Else
:  ... другие ...
:EndIf
```

### 5. Строковая конкатенация

```
:Disp "x"&string(j)&"=",val    ✅ использовать &
:Disp "x"+string(j)+"=",val    ❌ + не работает для строк
```

### 6. Матричные операции

**Размеры:**
```
:rowDim(mat)→m     получить количество строк
:colDim(mat)→n     получить количество столбцов
```

**Подматрицы:**
```
:subMat(mat,row1,col1,row2,col2)→result
```
Индексы с 1, границы включительно.

**Создание матриц:**
```
:newMat(rows,cols)→mat
:identity(n)→e
```

**Обращение:**
```
:mat^(-1)→inv
```

---

## Проблемы при разработке Gomory v0.1-v2.2.1

### Версия v0.1-v0.9: Инкрементальная сборка базовой структуры

**Проблемы:**
- Функция не появлялась → ошибка в последнем добавленном блоке
- Методология: добавлять по 5-10 строк, тестировать

**Решено:**
- Разработан рабочий скелет: input parsing, simplex tableau initialization

### Версия v1.0: Добавление Pause

**Проблема:**
```
:Disp "Iteration:",iter
:Pause               ❌ функция перестала компилироваться
```

**Решение:**
Удалить все `Pause`, использовать только `Disp`.

### Версия v2.0: LP relaxation работает

**Достижение:**
Прямой симплекс-метод работает, находит оптимальное решение релаксированной задачи.

### Версия v2.1: Добавление отсечений Гомори

**Проблемы:**
Множественные ошибки при расширении таблицы и добавлении строк отсечений.

#### v2.1.2: Z-row перезаписывается

**Проблема:**
```
:newMat(mult+1,pcol+1)→newtab
:For i,1,mult
:  ... копируем все строки ...
:EndFor
:For k,1,pcol
:  cutrow_data[k]→newtab[mult,k]   ❌ перезаписали Z-row!
:EndFor
```

**Причина:**
Копировали строки 1..mult (включая Z-row), затем перезаписывали строку mult данными отсечения.

**Решение:**
```
:For i,1,mult-1          ✅ копируем только constraint rows
:  ...
:EndFor
... добавляем cut в строку mult ...
... копируем Z-row в строку nr ...
```

#### v2.1.3: Неправильная ссылка на Z-row в dual simplex

**Проблема:**
```
:For k,1,pcol-1
:  tab[mult,k]/tab[prow,k]→val    ❌ mult уже не указывает на Z-row!
```

**Причина:**
После расширения таблицы Z-row переместилась в новую позицию `nr = mult+1`.

**Решение:**
```
:rowDim(tab)→nr
:For k,1,pcol-1
:  tab[nr,k]/tab[prow,k]→val      ✅ правильная ссылка
```

#### v2.1.4: RHS column перезаписывается

**Проблема:**
```
:For k,1,pcol
:  tab[i,k]→newtab[i,k]    ❌ копируем RHS в неправильную позицию!
:EndFor
```

**Причина:**
`pcol` в старой таблице — это RHS column. Новая таблица имеет дополнительный столбец slack, RHS должен быть в `nc = pcol+1`.

**Решение:**
```
:For k,1,pcol-1              ✅ копируем только переменные
:  tab[i,k]→newtab[i,k]
:EndFor
:0→newtab[i,pcol]           новый slack столбец
:tab[i,pcol]→newtab[i,nc]   RHS в правильную позицию
```

### Версия v2.2: Неправильное извлечение базисных переменных

**Проблема:**
```
:For j,1,n
:  For i,1,mult-1
:    If abs(tab[i,j]-1)<0.0001 Then    ❌ нашли 1, но не проверили уникальность!
:      tab[i,pcol]→val
```

**Причина:**
Просто искали элемент ≈1, но не проверяли, что это ЕДИНСТВЕННЫЙ ненулевой элемент в столбце.

**Пример:**
```
Столбец x2: [0.5, 1, 0.2]  ❌ нашли 1 в строке 2, но есть другие ненулевые!
```

**Решение:**
```
:0→cnt
:0→row
:For i,1,mult-1
:  If abs(tab[i,j])>0.0001 Then
:    cnt+1→cnt                         подсчитываем ненулевые
:    If abs(tab[i,j]-1)<0.0001 Then
:      i→row                           запоминаем позицию единицы
:    EndIf
:  EndIf
:EndFor
:If cnt=1 and row>0 Then              ✅ только если единственный ненулевой!
:  tab[row,pcol]→val
:EndIf
```

### Версия v2.2.1: Отсутствует вывод Z

**Проблема:**
```
:Disp "OPTIMAL INTEGER SOLUTION"
... печатаем переменные ...
                                    ❌ не печатаем Z!
:true→intdone
```

**Решение:**
```
:Disp "OPTIMAL INTEGER SOLUTION"
:Disp "Z=",tab[mult,pcol]         ✅ добавили вывод Z
:true→intdone
```

---

## Методология отладки

### 1. Инкрементальная разработка

**Стратегия:**
- Начать с минимальной функции (v0.1)
- Добавлять небольшие блоки (5-20 строк)
- Компилировать и тестировать после каждого добавления
- Если функция пропала → откатить последнее изменение

**Пример:**
```
v0.1: Prgm ... EndPrgm                    ✅ работает
v0.2: + input parsing                     ✅ работает
v0.3: + simplex initialization            ✅ работает
v0.4: + pivot selection                   ✅ работает
v0.5: + pivot operation                   ✅ работает
...
```

### 2. Диагностика через Disp

**Вместо отладчика:**
```
:Disp "DEBUG: pcol=",pcol
:Disp "DEBUG: prow=",prow
:Disp "DEBUG: tableau:"
:Disp tab
```

**Проверка условий:**
```
:If pcol=0 Then
:  Disp "DEBUG: No entering variable"
:EndIf
```

### 3. Проверка структуры таблицы

**После каждой операции:**
```
:Disp "After pivot:"
:Disp tab
:rowDim(tab)→m
:colDim(tab)→n
:Disp "Dimensions:",m,n
```

### 4. Валидация входных данных

**В начале программы:**
```
:Disp "Input matrix:"
:Disp mat
:Disp "Rows:",rowDim(mat)
:Disp "Cols:",colDim(mat)
```

---

## Ограничения и обходные пути

### 1. Поддерживаемые типы ограничений

**Работает:**
```
Ax ≤ b, где b ≥ 0
```

**НЕ работает напрямую:**
```
Ax ≥ b   →  нужно умножить на -1: -Ax ≤ -b
             но тогда -b < 0 → требует dual simplex с самого начала

Ax = b   →  нужны искусственные переменные и M-метод/двухфазный симплекс
```

**Обходной путь для ≥:**
1. Вручную умножить на -1
2. Решить другим методом (двойственный, двухфазный)
3. Или переформулировать задачу

### 2. Максимальные размеры задач

**Ограничения в коде:**
```
:While not done and iter<20      → макс. 20 итераций симплекса
:While not intdone and ncuts<10  → макс. 10 отсечений Гомори
:While not done and iter<10      → макс. 10 итераций dual simplex
```

**Можно увеличить**, изменив константы.

**Производительность:**
- 3-5 переменных, 2-4 ограничения: ~10-30 секунд
- Большие задачи: может потребоваться несколько минут

### 3. Точность вычислений

**Проблема:**
Floating-point арифметика → ошибки округления

**Решение в коде:**
```
:If abs(tab[i,j])>0.0001 Then        вместо =0
:If abs(tab[i,j]-1)<0.0001 Then      вместо =1
:If frac>0.0001 and frac<0.9999      избегаем граничных случаев
```

### 4. Монолитная vs модульная структура

**Попытка модульной структуры:**
```
func1()
func2()
func3()
gomory() вызывает func1(), func2(), func3()
```
❌ **Не работало** — функции не появлялись из-за синтаксических ошибок в подфункциях.

**Монолитная структура:**
```
gomory()
  ... весь код внутри одной функции ...
```
✅ **Работает** — проще отлаживать, все переменные в одном scope.

---

## Контрольный список для новых библиотек

### Перед компиляцией:

- [ ] Все присваивания в `Prgm` используют `→`, не `:=`
- [ ] Нет команд `Pause`
- [ ] Все строки в XML заканчиваются `&#13;`
- [ ] Атрибут `c="0"` присутствует на элементах `<e>`
- [ ] Строковая конкатенация использует `&`, не `+`

### После компиляции:

- [ ] Файл `.tns` создан в `build/`
- [ ] Скопирован в `/MyLib` на калькуляторе
- [ ] Выполнен `Refresh Libraries`
- [ ] Функция появилась в каталоге
- [ ] Тестовый вызов возвращает ожидаемый результат

### При ошибке "Variable is not defined":

- [ ] Проверить, появилась ли функция в каталоге
- [ ] Если нет → откатить последние изменения
- [ ] Собрать инкрементально, тестируя каждый блок
- [ ] Проверить синтаксис операторов (→ vs :=, & vs +)

---

## Успешные примеры из практики

### Библиотека `econ`
- Простые функции без циклов
- Использует встроенные функции (sum_prod)
- Компилировалась без проблем

### Библиотека `leontief`
- Матричные операции
- Программы с пошаговым выводом
- Вложенные циклы For
- Работает стабильно

### Библиотека `gomory`
- Сложная логика (симплекс + Гомори + dual simplex)
- Динамическое расширение таблиц
- Множественные вложенные циклы
- **Потребовала 21 итерацию разработки (v0.1 → v2.2.1)**
- Финальная версия стабильна и работает корректно

---

## Рекомендации

1. **Начинайте с простого** — минимальная работающая версия
2. **Инкрементально усложняйте** — по 5-20 строк за раз
3. **Тестируйте часто** — после каждого добавления
4. **Используйте Disp для отладки** — печатайте промежуточные результаты
5. **Проверяйте размеры матриц** — `rowDim()`, `colDim()` после каждой операции
6. **Избегайте модульности** — пока не уверены в синтаксисе
7. **Документируйте ошибки** — когда найдёте решение, запишите
8. **Будьте терпеливы** — TI-BASIC требует педантичности

---

**Версия документа:** 1.0
**Дата:** 2025-10-18
**Библиотека:** gomory v2.2.1 (финальная)
